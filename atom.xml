<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恋し</title>
  
  
  <link href="https://www.alexation.cn/atom.xml" rel="self"/>
  
  <link href="https://www.alexation.cn/"/>
  <updated>2023-09-02T07:19:02.364Z</updated>
  <id>https://www.alexation.cn/</id>
  
  <author>
    <name>恋し</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EYES THAT WATCH THE WORLD</title>
    <link href="https://www.alexation.cn/HelloWorld/"/>
    <id>https://www.alexation.cn/HelloWorld/</id>
    <published>2023-08-31T02:57:33.000Z</published>
    <updated>2023-09-02T07:19:02.364Z</updated>
    
    <content type="html"><![CDATA[<h1 align='center'><font style="font-family:华文行楷;font-weight:500;font-size=50px;">观黑夜如白昼，洞微处若观火</font></h1><p><font style="font-family:华文行楷;font-size:24px">    你好，很高兴以这种方式认识你。在这里，我会分享我的生活趣事、研究成果、新奇想法等任何值得记录下来的美好事物。这里陪伴我的两年以来，本篇文章经历了三次修改，同时我本身也有着很大的变化。 慢慢长大，我又慢慢把一段段时光放回一篇篇文章中重新咀嚼，一个个故事、一次次想法、一段段回忆互相联系起来。本以为是痛苦的经历本身竟然如此浪漫。</font></p><br><p><font style="font-family:华文行楷;font-size:24px">    这个世界上会有突如其来的遇见和始料未及的喜欢，当然也会有猝不及防的再见和毫不留情的散场。春花，夏风，秋月，冬雪，四季轮回。我懵懂地消化那些故事，笨拙地感受成人思维里的世界，我开始小心翼翼，我开始意识到语言就像利刃，一旦使用不当就会变成可怕的凶器，一旦错过，可能就永远不会再见。同时，我寄予文字以希望，相信其振奋人心的作用，相信其最真诚的祝福，相信其带来最美好的回忆。</font></p><blockquote><p><font style="font-family:华文行楷;font-size:24px">希望我们都能感到被理解、被看见。</font></p></blockquote><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=468710207&bvid=BV1W541127zq&cid=588846146&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 align=&#39;center&#39;&gt;&lt;font style=&quot;font-family:华文行楷;font-weight:500;font-size=50px;&quot;&gt;观黑夜如白昼，洞微处若观火&lt;/font&gt;&lt;/h1&gt;
&lt;p&gt;&lt;font style=&quot;font-family:华文行楷</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2022湖北省大学生电子设计竞赛E题（TI杯）</title>
    <link href="https://www.alexation.cn/contest/ele3/"/>
    <id>https://www.alexation.cn/contest/ele3/</id>
    <published>2023-06-17T20:05:30.000Z</published>
    <updated>2023-09-02T06:13:50.479Z</updated>
    
    <content type="html"><![CDATA[<p><font style="font-weight:700;color:#B399FF"><em>关于作者：本科大三在读，电气专业。基础不好，不喜勿喷，感谢访问本网站，如果能给你提供新思路就是我最大的荣幸！</em></font></p><p><a href="https://ctgu.site:8003/index.php/s/EDfeLHr87T8nqBF" style="font-weight:700;color:#B399FF"><em>点击此处获取2022年TI杯大学生电子设计竞赛参考赛题</em></a></p><h2 style="text-align:center;font-weight:700;color:#B399FF">关于题目</h2><p>​设计制作一个声源定位跟踪系统，能够实时显示及指示声源的位置，当声源移动时能够用激光笔动态跟踪声源。 声源检测系统测量区域分布俯视如图 1 所示。</p><p><img src="https://s2.loli.net/2023/06/18/sCorxdA1bIMSjEn.jpg" alt="图1 系统测量区域俯视图"></p><h4 id="要求">要求</h4><ol><li>设计并制作声音发生装置——“声源”，装置能独立工作，声音音量手动可调，装置最大边长或直径不超过 10cm，装置可用支架安装，并可在地面移动；声源中心点 B 用红色或其他醒目颜色标识，并在 B 点所在的平面以 B 点为圆心，直径为 5cm 画圆圈，用醒目线条标识，该平面面向检测指示装置（图中 A 点）。（4 分）</li><li>设计并制作一个声源定位检测装置，传感器安装在图 1 的 C 区范围内，高度不超过 1m，系统采用的拾音器 或麦克风传感器数量不超过 10 个；在装置上标记测试参考点 A，作为位置坐标的原点；装置上有显示电路，实时显 示 D 区域内声源的位置，显示 A、B 两点直线距离 γ 和以 A 点为原点，AB 在地面的投影与图 1 中心线的夹角 θ， 测量时间不超过 5s，距离 γ 和角度 θ 的测值误差越小越好。（36 分）</li><li>设计并制作一个声源指示控制装置，此装置和上述声源定位检测装置可以合为一体。也放置在图 1 的 C 区， 安装有激光笔和二维电动云台，能控制激光笔指向声源，定位计算过程中时，激光笔关闭，定位运算完成时激光笔 开启。定位指示声源时，动作反应时间不超过 10s，光点与 B 点偏差越小越好。（30 分）</li><li>声源移动动态追踪：当声源摆放在地面，用细绳牵引，以 0.2m/s 左右的速度在 D 区移动时，激光笔光点指 向 B 点，光点与 B 点偏差越小好，跟踪反应时间越短越好。（20 分）</li></ol><h2 style="text-align:center;font-weight:700;color:#B399FF">解题过程</h2><p>听说Sipeed的MIC阵列模块可以秒杀E题？解题过程？不存在的</p><p><a href="https://wiki.sipeed.com/hardware/zh/modules/micarray.html">MicArray 麦克风阵列 - Sipeed Wiki</a></p><p>对就是这个<span class="emoji" alias="anguished" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f627.png?v8">😧</span></p><p>包括官方还给了一个2022年电赛E题声源定位跟踪系统做好的链接，直接套用代码接线就可以。。。所以我直接照着完善了一下代码框架，接上线后由于阵列模块非常容易受干扰（当然可以通过选择音源提高效果），所以需要进行一些处理。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from Maix import MIC_ARRAY as micimport lcd, imageimport timeimport mathfrom Maix import GPIOfrom fpioa_manager import fmfrom machine import Timer, PWM# MIC-IOmic.init(i2s_d0&#x3D;32, i2s_d1&#x3D;33, i2s_d2&#x3D;34, i2s_d3&#x3D;35, i2s_ws&#x3D;9, i2s_sclk&#x3D;10, sk9822_dat&#x3D;11, sk9822_clk&#x3D;15)# Laser-IOfm.register(7, fm.fpioa.GPIO0)Laser &#x3D; GPIO(GPIO.GPIO0, GPIO.OUT)# KEY-IOfm.register(26, fm.fpioa.GPIO1)KG0 &#x3D; GPIO(GPIO.GPIO1, GPIO.IN, GPIO.PULL_DOWN)fm.register(27, fm.fpioa.GPIO2)KG1 &#x3D; GPIO(GPIO.GPIO2, GPIO.IN, GPIO.PULL_DOWN)# SERVO-IOtim &#x3D; Timer(Timer.TIMER0, Timer.CHANNEL0, mode&#x3D;Timer.MODE_PWM)Servo_laser &#x3D; PWM(tim, freq&#x3D;50, duty&#x3D;0, pin&#x3D;17)# LCD-INIT-320*240 and MAP-INITlcd.init()lcd.fill_rectangle(46, 5, 230, 4, (255, 0, 0))  # 上边线lcd.fill_rectangle(46, 5, 4, 230, (255, 0, 0))  # 左边线lcd.fill_rectangle(46, 235, 230, 4, (255, 0, 0))  # 下边线lcd.fill_rectangle(276, 5, 4, 234, (255, 0, 0))  # 右边线lcd.fill_rectangle(237, 5, 4, 234, (255, 0, 0))  # 右边线2lcd.fill_rectangle(0, 77, 47, 4, (255, 0, 0))  # 左区域上边线lcd.fill_rectangle(0, 154, 47, 4, (255, 0, 0))  # 左区域下边线lcd.fill_rectangle(0, 77, 4, 77, (255, 0, 0))  # 左区域左边线class Argument:    &quot;&quot;&quot;Some Argus&quot;&quot;&quot;    def __init__(self):        super(Argument, self).__init__()        # Normal        self.num &#x3D; 0        self.num2 &#x3D; 0        self.Angle_LB &#x3D; [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]        self.t &#x3D; 0        self.t1 &#x3D; 0        self.t2 &#x3D; 0        self.maxnum &#x3D; 0        self.minnum &#x3D; 0        self.jiaodu &#x3D; 0        self.Angle_last &#x3D; 0        self.b &#x3D; [3, 1, 2, 5, 6]        self.i &#x3D; 100        self.a &#x3D; []        self.times &#x3D; 0        self.pid &#x3D; 0        self.err &#x3D; 0        self.JD &#x3D; 0        self.output &#x3D; 0        # Kalman Filter        self.KF_lastP &#x3D; 0.1  # 上次的协方差        self.KF_nowP &#x3D; 0  # 本次的协方差        self.KF_x_hat &#x3D; 0  # 卡尔曼滤波的计算值，即为后验最优值        self.KF_Kg &#x3D; 0  # 卡尔曼增益系数        self.KF_Q &#x3D; 0  # 过程噪声        self.KF_R &#x3D; 0.01  # 测量噪声arguments &#x3D; Argument()def kalman_filter(argus, value):    argus.output &#x3D; 0  # output为卡尔曼滤波计算值    x_t &#x3D; argus.KF_x_hat  # 当前先验预测值 &#x3D; 上一次最优值    argus.KF_nowP &#x3D; argus.KF_lastP + argus.KF_Q  # 本次的协方差矩阵    argus.KF_Kg &#x3D; argus.KF_nowP &#x2F; (argus.KF_nowP + argus.KF_R)  # 卡尔曼增益系数计算    argus.output &#x3D; x_t + argus.KF_Kg * (value - x_t)  # 当前最优值    argus.KF_x_hat &#x3D; argus.output  # 更新最优值    argus.KF_lastP &#x3D; (1 - argus.KF_Kg) * argus.KF_nowP  # 更新协方差矩阵def servo(servo_inter, angle):    servo_inter.duty((angle + 90) &#x2F; 180 * 10 + 2.5)while True:    # Inner Params: [AngleX, AngleY, AngleR, Angle, AngleAddPi]    angle_params &#x3D; [0, 0, 0, 0, 0]    # MIC-Detecting    img_a &#x3D; mic.get_map()    img_b &#x3D; mic.get_dir(img_a)    mic.set_led(img_b, (10, 10, 0))    # If Ques 3    if KG0.value() &#x3D;&#x3D; 1 and KG1.value() &#x3D;&#x3D; 0:        arguments.times +&#x3D; 1        if arguments.times &#x3D;&#x3D; 1:            time.sleep(1)            Laser.value(0)    # Angle    for i in range(len(img_b)):        if img_b[i] &gt;&#x3D; 0:            angle_params[0] +&#x3D; img_b[i] * math.sin(i * math.pi &#x2F; 6)            angle_params[1] +&#x3D; img_b[i] * math.cos(i * math.pi &#x2F; 6)    angle_params[0] &#x3D; round(angle_params[0], 6)    angle_params[1] &#x3D; round(angle_params[1], 6)    if angle_params[1] &lt; 0:        angle_params[4] &#x3D; 180    if angle_params[0] &lt; 0 and angle_params[1] &gt; 0:        angle_params[4] &#x3D; 360    if angle_params[0] !&#x3D; 0 or angle_params[1] !&#x3D; 0:        if angle_params[1] &#x3D;&#x3D; 0:            angle_params[3] &#x3D; 90 if angle_params[0] &gt; 0 else 270        else:            angle_params[3] &#x3D; angle_params[4] + round(math.degrees(math.atan(angle_params[0] &#x2F; angle_params[1])), 4)        # Determine the scope        if 90 &lt; angle_params[3] &lt; 270:            angle_params[3] &#x3D; arguments.Angle_last * 0.1 + angle_params[3] * 0.9            kalman_filter(arguments, angle_params[3])            arguments.Angle_last &#x3D; angle_params[3]            show_angle &#x3D; 180 - angle_params[3]            # Check Ques 3            if KG0.value() &#x3D;&#x3D; 1 and KG1.value() &#x3D;&#x3D; 0:                Laser.value(1)                servo(Servo_laser, show_angle)            lcd.draw_string(60, 200, &quot;Angle: &quot; + str(show_angle), lcd.BLUE, lcd.BLACK)            lcd.draw_string(60, 180, &quot;Distance: &quot; + str(275 &#x2F; math.cos(-show_angle * math.pi &#x2F; 180)), lcd.BLUE,                            lcd.BLACK)            lcd.fill_rectangle(251, 10, 25, 225, (0, 0, 0))            location &#x3D; int(108 + math.tan(-show_angle * math.pi &#x2F; 180) * 48)            print(show_angle, location)            if 0 &lt; location &lt; 200:                lcd.fill_rectangle(251, location, 15, 15, (0, 255, 200))            # Check Ques 4            if KG0.value() &#x3D;&#x3D; 1 and KG1.value() &#x3D;&#x3D; 1:                arguments.JD &#x3D; angle_params[3]                Laser.value(1)                error &#x3D; arguments.JD - arguments.pid                arguments.pid +&#x3D; error * 0.1                arguments.output &#x3D; -arguments.pid                if -270 &lt; arguments.output &lt; -90:                    servo(Servo_laser, 180 + arguments.output)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 style="text-align:center;font-weight:700;color:#B399FF">反思总结</h2><ol><li>音源很重要</li><li>可以滤波</li><li>可以PID控制舵机提高稳定性</li></ol>]]></content>
    
    
    <summary type="html">大三老学长的一次划水校赛记录、、、</summary>
    
    
    
    <category term="竞赛" scheme="https://www.alexation.cn/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="Python" scheme="https://www.alexation.cn/tags/Python/"/>
    
    <category term="可恶的电赛" scheme="https://www.alexation.cn/tags/%E5%8F%AF%E6%81%B6%E7%9A%84%E7%94%B5%E8%B5%9B/"/>
    
    <category term="pyAI-K210" scheme="https://www.alexation.cn/tags/pyAI-K210/"/>
    
  </entry>
  
  <entry>
    <title>美国得克萨斯州2·14大停电</title>
    <link href="https://www.alexation.cn/other/PowerOutage/"/>
    <id>https://www.alexation.cn/other/PowerOutage/</id>
    <published>2023-05-01T04:04:28.000Z</published>
    <updated>2023-09-02T07:08:03.553Z</updated>
    
    <content type="html"><![CDATA[<h2 style="text-align:center;font-weight:700;color:#B399FF"><em>2021 Texas Power Crisis</em></h2><h3 id="作者前言">作者前言</h3><p>        该事故调查报告完全基于互联网分析，因此无法保证数据的准确性。同时还有以下注意要点<sup>[1]</sup>：</p><ul><li>本文档中的信息是初步信息，可能受到发生变化后统计不及时的影响。</li><li>就本文件而言，“停电”是发电机容量完全不可用，“减额”是该容量部分不可用。</li><li>图表中反映的所有发电机停机和降额值均基于发电机铭牌容量，即发电机制造商指定的最大可能 MW 输出。 由于风能和太阳能输出通常远低于指定的铭牌容量，因此用于编写本报告的这些单元的停电和降额 MW 值通常远高于在没有停电的情况下可用的实际电量或减额。</li><li>无法披露特定单元的停电原因，因为它们是受保护的信息。</li></ul><p>        本次报告的大部分数据来自于ERCOT（得州电力可靠性协会），部分观点可能来自统计学家或者专家分析。此外，该报告依据中华人民共和国应急管理部办公厅发布的相应要求<sup>[2]</sup>编写（字体、图表、排版以及部分细节等未进行格式规范）。</p><h2 style="text-align:center;font-weight:700;color:#000">美国得克萨斯州2·14特别重大电力安全事故调查报告</h2><h3 id="一、报告开篇和事故性质认定">一、报告开篇和事故性质认定</h3><p>        2021年得克萨斯州大停电是指美国得克萨斯州在2021年2月中因为极端天气而出现的大规模停电事件。高峰时得州有450万户家庭和企业停电，州内供水设施、食物供应链和网络通讯设施也受到影响。经调查认定，此次大停电事故是一起因寒潮这一直接原因造成的电力安全事故。</p><h3 id="二、事故基本情况">二、事故基本情况</h3><p>        为了更好地分析事故的起因以及影响，充分了解事故发生的地点、时间以及管理单位等关键信息是必需的。</p><h4 id="（一）事故发生单位及相关单位概况">（一）事故发生单位及相关单位概况</h4><p>        美国电网迄今已有100多年的建设发展历史，最初是由私营和公营电力公司根据各自的负荷和电源分布组成一个个孤立的电网，随后在互利原则基础上通过双边或多边协议、联合经营等方式相互联网，逐步形成了东部、西部和得克萨斯三大联合电网， 这三大联合电网之间仅由少数低容量的直流线路连接，分别占美国售电量的73%、19%和8%。美国的输电网纵横交错，常见的电压等级有765千伏、500千伏、345千伏、230千伏、161千伏、138千伏、115千伏。据美国能源信息署（EIA）统计， 2012年美国200千伏以上高压输电线路有30.7万公里，其中包括约3888公里的765千伏交流输电线路，以及3545 公里±500千伏直流输电线路<sup>[3]</sup>。从将各种电力资源可靠地整合到电网，到为北美三分之二的地区协调发电和输电，ISO 和 RTO 使发电与保持照明的需求即时匹配<sup>[4]</sup>。</p><img src="https://www.ctgu.site/media/Electric.jpg" alt="图1 主要电网互联系统" style="zoom:50%;" /><p>        而本次大停电事故发生地点在美国得克萨斯州，作为该地区的独立系统运营商，ERCOT 在连接超过 52,700 英里输电线路和 1,100 台发电机组（包括专用网络）的电网上安排电力。 它还为竞争激烈的批发大容量电力市场执行财务结算，并管理竞争选择区域中 800 万处场所的零售交换。 ERCOT 是一家会员制 501©(4) 非营利性公司，由董事会管理，并受德克萨斯州公用事业委员会和德克萨斯州立法机构的监督。 其成员包括消费者、合作社、发电商、电力营销商、零售电力供应商、投资者拥有的电力公司、输电和配电供应商以及市政拥有的电力公司<sup>[5]</sup>。</p><h4 id="（二）事故发生单位安全管理情况">（二）事故发生单位安全管理情况</h4><p>        早在2011年，ERCOT已经存在一套完整的紧急操作，该操作旨在解决 ERCOT 系统可靠性不足且没有显而易见的解决方案的的紧急情况<sup>[6]</sup>。</p><h4 id="（三）事故发生经过">（三）事故发生经过</h4><p>        2021年2月，得克萨斯州遭遇了一场重大电力危机，这是在2月10日至11日、13-17日、和15-20日横扫美国的三场严冬风暴期间发生的。 风暴引发了德克萨斯州历史上最严重的能源基础设施故障，导致水、食物和热量短缺<sup>[7]</sup>。 超过 450 万家庭和企业断电，有的断电好几天。 至少有246人直接或间接丧生，据估计，这场危机造成的死亡人数高达702人。</p><h4 id="（四）人员伤亡和直接经济损失情况">（四）人员伤亡和直接经济损失情况</h4><p>        到2月17日，至少有21人死于与冬季风暴有关的原因。 到2月19日，这一数字更新为至少32人死亡，死亡与一氧化碳中毒、车祸、溺水、房屋火灾和体温过低有关。2月21日，死亡人数增加到70人<sup>[8]</sup>。据估计，寒潮和冬季风暴造成的损失至少为 1950 亿美元。</p><h4 id="（五）其他情况">（五）其他情况</h4><ul><li>由于管道冻结和爆裂，超过 1200 万人的供水服务中断<sup>[9]</sup>。</li><li>恶劣的天气导致许多消防栓在紧急情况下无法使用。</li><li>由于停止和启动化石燃料基础设施（例如化工厂和燃料精炼厂）而导致污染物大量释放。</li><li>得克萨斯州的电网危机已经扩大到不仅仅是一场自然灾害和治理失败。</li><li>COVID-19疫苗的运送被延迟，无法正确储存疫苗的设施被要求将疫苗转移给可以储存疫苗的设施。</li><li>由于全州持续停电，许多人在家中面临冰冻温度。</li><li>…</li></ul><h3 id="三、事故应急处置及评估情况">三、事故应急处置及评估情况</h3><p>        从事故发生到结束，政府以及社区的事故应急处置能力以及紧急情况响应速度都对事故范围有着很大影响。</p><h4 id="（一）事故信息接报及响应情况">（一）事故信息接报及响应情况</h4><p>        州长阿博特于2月12日发布了一份灾难声明，据此他动员了包括德克萨斯军事部在内的各个部门进行除雪和援助滞留的驾车者。随着局势的恶化，州长阿博特于2月13日要求发表联邦紧急声明，拜登总统于2月14日批准了该声明。</p><p>        为了缓解能源短缺，州长阿博特命令天然气生产商不要将天然气出口到州外，而是在德克萨斯州内销售。他还呼吁 ERCOT 领导人辞职。前众议员 Beto O’Rourke 经营着一家虚拟电话银行，可以联系全州超过780,000名老年人。得克萨斯州科罗拉多市市长蒂姆·博伊德 (Tim Boyd) 发表评论批评市民没有为冬季风暴做准备，并表示：“强者生存，弱者灭亡”后，遭到强烈反对。 他在争议后辞职。</p><p>        2月14日，拜登总统宣布德克萨斯州进入紧急状态，授权国土安全部和联邦紧急事务管理局（FEMA）在德克萨斯州全境提供紧急援助。FEMA 向该州发送了 60 台发电机以及水和毯子。</p><p>        当地教堂、社区中心和其他地点为受影响的个人开设了暖气站，并要求提供物质和金钱捐赠以帮助受影响的人。几个当地的互助团体以物资的交付和分配作为回应，特别是在受灾最严重的休斯顿和奥斯汀地区。碧昂斯 (Beyoncé) 和瑞茜·威瑟斯彭 (Reese Witherspoon) 等名人与公司合作提供金钱救济，亲自捐款，并向社交媒体粉丝提供捐款链接，以提高救济和意识。 通过他的“我们是德克萨斯”虚拟慈善音乐会，Matthew McConaughey 和他的妻子 Camila Alves McConaughey 筹集了超过 770 万美元，以继续支持受风暴影响的人们。</p><p>        国会女议员亚历山大·奥卡西奥-科尔特斯组织了一场筹款活动，为受影响的德克萨斯人提供食物、水和住所，第一天就筹集了 200 万美元。她随后前往休斯敦与志愿者一起帮助康复。 她和其他民主党人一起参观了风暴留下的破坏以及配送中心和交付地点。 最后，她筹集了 470 万美元<sup>[10]</sup>。</p><h3 id="四、事故原因分析">四、事故原因分析</h3><p>        德克萨斯州的绝大多数家庭都配备了电加热器，其技术相当于烤面包机烤箱。在最严重的冷锋期间，居民们启动了那些效率低下的单位，有些人甚至打开和打开电烤箱并使用吹风机。结合事故发生的背景以及外内部因素等，事故的直接原因是：寒潮造成电力需求急剧升高，以及得克萨斯州的电力设备没有良好的防冻措施并且极端低温与冻雨天气导致的机组非计划停运、降功率运行及无法开机等发电侧故障。</p><h4 id="（一）直接原因分析">（一）直接原因分析</h4><p>        与极端天气相关的强制停电数量可能有多种触发因素，但总的来说，它们似乎分为两大类。这些类别是<sup>[11]</sup>：</p><ol><li>机组无法启动或维持与气候相关的运行状态，包括基于燃料的设施以及可再生能源（主要是风能）</li><li>优先权的减少或丧失将天然气重新分配给燃气设施。</li></ol><img src="https://www.ctgu.site/media/Fuel_type.png" alt="图2 燃料减额量" style="zoom: 25%;" /><p>        由极端低温、冻雨天气直接造成的发电侧故障是事故的首要原因。应该指出的是，风能资产受到了极大的关注，但事实表明，所有资源都受到了实质性影响，没有一类资源比其他资源受到的影响更大。结合图2的燃料减额量<sup>[12]</sup>注意到天然气以及风能供应占比较大而且都受到了很大影响。</p><p>        例如，风机叶片结冰可能导致风电机组非计划停运或降功率运行，发电厂控制和信号装置内测压水柱冻结可能引发装置误动，发电厂给水系统、通风系统、润滑系统等内部液体冻结可能导致设备无法正常工作等。在寒冷潮湿的条件下旋转的风力涡轮机叶片可以在其叶片宽一码的尖端积聚近一英尺厚的冰。这会破坏叶片空气动力学。 这破坏了整个涡轮机的平衡。 根据爱荷华州立大学 Martin C. Jischke 航空航天工程教授和该大学飞机结冰物理学和防/除冰主任 Hui Hu 领导的一项最近发表的实地研究，这可能会中断高达 80%的能源生产<sup>[13]</sup>。Hu 从事涡轮叶片结冰的实验室研究已有大约 10 年，包括在独特的 ISU 结冰研究隧道中进行实验。 其中大部分工作得到了爱荷华州能源中心和国家科学基金会的资助。</p><p>        一些风力涡轮机确实冻结了，但占该州发电量一半左右的天然气是造成短缺的主要原因。 工厂崩溃了，天然气供应链和管道也崩溃了。</p><p>        通常有两个与受恶劣天气事件影响的电网架构相关的组件：弹性和可靠性。电网弹性是承受电网压力事件而不会遭受操作损害或适应压力的能力。这主要是关于电网或电力消费者不会发生什么。 简而言之，弹性是电气系统在不持续断电的情况下应变或变形的能力。另一方面，可靠性是衡量弹性被破坏后的行为的指标。持续中断的开始是从弹性域到可靠性域的过渡点。</p><p>        在这个极端的冬季事件中，ERCOT 管理系统以满足在这个极端天气事件发生时 ERCOT 监管、运营和市场限制范围内的可靠性参数，以避免整个系统出现故障。紧急系统措施采用了减载，以避免电气系统完全受损。电网可靠性的主要组成部分之一是资源储备的可用性，可以在发电资源持续中断期间将其部署到电网。在这次事件中，在线发电和资源储备，包括备用和备用发电资源，都受到极端温度的影响，无法满足负荷需求。这反过来又需要减载以维持供需的实时平衡。</p><img src="https://www.ctgu.site/media/Net Generator Outages and Derates by Cause.png" alt="图3 发电机停机以及减额原因" style="zoom: 33%;" /><p>        图3中显示的停电容量随着周日风暴的到来而急剧增加，并从周一上午晚些时候到周三中午保持相当稳定。然而，如图4所示，停电的净水平掩盖了整个星期持续的发电可用性波动，在整个活动期间，发电机不断停运和投入使用。</p><img src="https://www.ctgu.site/media/Incremental Generator Outage and Derates by Hour.png" alt="图4 增量式发电机停电和按小时降额" style="zoom: 33%;" /><p>        极寒天气下机组燃料问题导致的发电侧故障是事故的第2个重要原因，而这部分故障中，以天然气为燃料的机组故障占87%，其他燃料导致的故障仅占13%。一方面，极端低温、冻雨天气使得天然气井井口发生冻结，道路交通运输条件也随之恶化，天然气设施的维修无法正常进行，为了防止冰冻带来的影响，部分天然气设施提前关停，这使得天然气产量大幅下降；另一方面，天然气设施的供电，也因极寒天气导致的电厂故障与负荷轮停而面临严重不足，这进一步限制了天然气的生产<sup>[14]</sup>。启动负荷轮停时的一大疏忽，恰恰在于没有将天然气设施作为关键负荷，保障其电力供应，导致了“正反馈”式的传播效应。由机组燃料问题引发的大量发电侧故障，与美国中南部及得州区域燃气机组装机容量占比过半以及电-气能源间的紧密耦合（electricity-gas interdependence）是密不可分的。</p><h4 id="（二）间接原因分析">（二）间接原因分析</h4><p>        1999年，得克萨斯州设定了可再生能源目标。如今，得州的风能占全美的30%左右。但此次供电系统的崩溃则使人们开始质疑得州的电力系统设计与其不断推进的可再生能源计划是否有一定风险。部分责任归咎于德克萨斯州电力市场的独特设计。 在美国 48 个相邻的州中，它是唯一一个拥有自己独立电网的州——得克萨斯互联。 这意味着当发电机发生故障时，该州无法从境外进口电力。但是即使存在跨州调节的可能性，与ERCOT相邻的SPP和MISO也因极寒天气而面临电力供应紧张，且彼此间的传输线也受天气影响多遇故障，导致ERCOT至多仅能从相邻电网受入略超100万千瓦的电力，也难以有效缓解电力供应危机。</p><p>        美国两党政客数十年以来一直在推动的对可再生能源的补贴，使得电网变得不稳定。与风能相较，煤炭和核能受到更严格的监管，这使得州等多地的燃煤电厂因缺乏竞争力而关闭。过去10年里，全美停止运营的燃煤电厂大约可为6000万户家庭提供电力。此外，许多核电站也陆续关闭。然而，电网对风能和太阳能等间歇性可再生能源的依赖程度越高，在供需发生巨大变化时的稳定性就越低。在质疑者看来，得州此次的电网崩溃显示出了可再生能源的风险与局限性。那么，寒潮过后该州面临着两个主要问题：是否要增加电力储备能力，以及如何确保电力设备应对极端天气的能力。</p><h3 id="五、有关责任单位存在的主要问题">五、有关责任单位存在的主要问题</h3><h4 id="（一）事故单位">（一）事故单位</h4><p>        运营电网的德克萨斯州电力可靠性委员会 (ercot) 没有正确预测风暴导致的能源需求是导致这次事故的一个潜在原因。 有人说这几乎是无法预测的，但在前一周就有关于即将到来的恶劣天气的警告，而 ercot 的预测非常短。 能源投资银行 Tudor, Pickering, Holt &amp; Co (tph) 的乔治·奥利里 (George O’Leary) 表示，去年夏天的限电已经表明电网缺乏过剩产能<sup>[15]</sup>。</p><p>        负荷的持续激增及发电机组的大面积停运使得整个电力系统的频率不断下降，在2月15日凌晨12点18分系统频率已降至正常线以下，因此，ERCOT在凌晨1点20分启动了两轮100万千瓦的负荷轮停，但频率仍在降低，情况最坏时留给ERCOT处理频率过低问题的时间只剩9分钟，否则将可能触发1700万千瓦的机组因频率过低而停机，并导致系统大停电。可见，ERCOT当时采取大规模的负荷轮停亦是无奈之举。</p><p>        在此事件之前，ERCOT 服务区域在 2011 年 2 月的第一周以及 1983 年、1989 年、2003 年、2006 年、2008 年和 2010 年经历了类似的极端寒冷天气事件。以下内容总结在执行摘要中2011 年 FERC 员工报告<sup>[16]</sup>：</p><blockquote><p>​“进入 2011 年 2 月的暴风雨，无论是 ERCOT 还是在事件期间启动轮流停电的其他电力实体都预计无法满足客户需求。 根据预期的发电机可用性，它们都有足够的备用裕度。 但事实证明，这些储备不足以应对事件期间因跳闸、降额和启动失败而损失的大量容量。”</p></blockquote><p>        从本质上讲，该报告的结果似乎与2021年极端冬季风暴事件的结果一致。该报告的建议包括26条建议，以提高极端冬季天气事件期间的可靠性能。2011年和2021年极端天气事件的发生时间（2月）和类型都相似。然而，在2021年，由于强制停电以及由于强制停电而无法使用的机组总数，发电量损失明显增加。在2021年的活动期间，供不应求导致的频率偏差变得更加严重。鉴于建议是在2011年事件之后制定的，问题仍然是为什么类似的事件会产生类似的结果，但应该指出的是，2021年的事件在低温方面更为“极端”。</p><h4 id="（二）有关监管部门">（二）有关监管部门</h4><p>        根据 PJM 的强制执行标准，《联邦电力法》第 215 条要求电力可靠性组织 (ERO) 制定强制性和可执行的可靠性标准，这些标准须经 FERC 审查和批准。 根据委员会批准的与可靠性标准相关的 NERC 实施计划，委员会批准的可靠性标准在美国成为强制性的和可执行的。 根据 2005 年能源政策法案 (EPAct 2005)，国会通过添加与电网可靠性相关的新第 215 条，扩大了 FERC 在联邦电力法案 (FPA) 下的作用和管辖权。 FPA 第 215(e) 节授权委员会或电力可靠性组织（由 FERC 审查）对违反可靠性标准的大容量电力系统的用户、所有者或运营商处以罚款。</p><p>        由于 ERCOT 独立系统运营商管理的输电网仅位于德克萨斯州内，并未与美国其他地区同步互连，因此完全在 ERCOT 内发生的电能传输在某些情况下不受委员会管辖 《联邦权力法》的执行部分。 大容量电力系统的可靠性已通过 NERC 与 Texas RE 之间的授权协议进行授权，该协议将合规性和执法权授予 Texas RE，以确保大容量电力系统维持 NERC 可靠性标准。 确定 Texas RE 是否具有关于发电设施风化的合规和执法权限需要对 NERC 和 Texas RE 之间的 ERO 协议中的陈述进行更详细的评估。</p><h3 id="六、事故主要教训">六、事故主要教训</h3><p>        从1983年到2021年，相对于我国连续三十年无大停电事故，如此高频率的停电已经不是偶然因素导致。尽管事故后有应急处置、原因分析、后续调查等一系列流程化措施，但是数十年来仍得不到有效改观，甚至截至 2022 年 1 月，电力系统几乎没有变化，德克萨斯州仍然面临另一场冬季风暴中大停电的风险<sup>[17]</sup>。</p><p>        对于发电侧以及天然气供给侧均应在寒潮到来前做充足得组合预测，提前准备应急人员与建立互助项目等。虽然分散式电网管理体制增加电网规划、建设、运营协调难度，不利于电网协调可持续发展，以及美国电网产权分散、 管理分散，形成区域化发展格局，难以整合成协调统一的全国性电网。但是多年来相关企业得预测不准确及时以及事后设备改建不充分等要素共同导致了这次事故，只有相关企业能够加大改进力度，才能避免再次发生大面积停电事故。</p><h3 id="七、事故整改和防范措施">七、事故整改和防范措施</h3><h4 id="（一）对发电侧的建议">（一）对发电侧的建议</h4><ol><li>发电机所有者（Generator Owner，GO）应负责辨识容易受寒冷天气影响的发电设备或系统。</li><li>发电机所有者应对易受严寒影响的设备或系统明确并执行防冻保护措施，并每隔一段时间分析设备系统是否变化，是否需要额外的防冻措施。</li><li>发电机所有者在提供运行温度数据时需同时考虑降雨及冷风对机组运行的影响。</li><li>发电机所有者应审查出现故障的机组并制定修正行动方案（Corrective Action Plan，CAP），进一步修订往后的寒冷天气应对计划。</li><li>发电机所有者与发电机运行人员（Generator Operators，GOP）每年对每台机组都应开展针对寒冷天气预防计划的测试。</li><li>发电机所有者应改造现有机组，使其在规定温度与天气条件下（参考该地区的历史极端温度与天气）能够正常运行。</li><li>在计算寒冷天气下的可信容量并用于紧急运行调度时，发电机所有者应综合天然气的供应情况向功率平衡责任主体（Balancing Authorities，BA）提供可靠的可信容量预测，功率平衡责任主体应进一步综合自身判断向可靠性协调机构（Reliability Coordinators，RC）提供可靠预测，并据此制定应急管理计划。</li><li>发电机所有者应至少在入冬前、冬季中、收到极端天气的预报等时点，定期检查并维护机组的防冻措施。</li><li>为了向功率平衡责任主体提供准确信息，发电机所有者及发电机运行人员应明确所有与发电机组使用的天然气的购买和运输相关的可靠性风险。</li><li>发电机所有者应综合考虑极寒天气下机械压力、热循环疲劳、热压力等对过滤器、锅炉、管道、布线等部件与系统的影响，并制定措施预防极寒天气下的机械与电气故障。</li><li>发电机所有者在极寒天气来临前应考虑天气预测制定发电机组的运行计划，尽可能降低严寒天气对机组出力及可靠性的影响。</li><li>发电机所有者应检查发电机低频继电器、机组平衡继电器以及与控制系统相关的调节参数的设置是否匹配，避免导致发电机组在低频或频率变化过快的情况下跳闸。</li></ol><h4 id="（二）对天然气供给的建议">（二）对天然气供给的建议</h4><ol><li>国会、立法机构以及天然气设施管制机构，应要求天然气设施制定寒冷天气预防计划，包括如何应对特定的寒冷天气并运行。</li><li>天然气设施应采取保护措施以应对冰冻等其他寒冷天气情况，包括脆弱设备防冻、准备充足应急人员、建立互助项目等。</li><li>天然气生产设施的所有者或运营商应升级其检测控制与数据采集系统，以便在紧急情况下实时地增加或减少其产量。</li><li>由FERC牵头，组织对天然气基础设施拥有管制权的单位与区域可靠性组织等单位，建立多方论坛讨论方案以提升支撑电力系统生产的天然气基础设施的运行可靠性，讨论问题包括天然气系统的信息是否需要向电力系统共享、天然气系统防冻措施的合理补偿途径、天然气储存设备是否需要增加等。</li><li>功率平衡责任主体禁止关键天然气基础设施（电）负荷的需求侧响应项目，避免因需求响应项目导致天然气产量下降。</li><li>功率平衡责任主体与输电系统操作员（Transmission Operators，TOP）允许天然气基础设施辨识关键（电）负荷，禁止人工削减其关键负荷，负荷削减机构将这些关键负荷纳入计划方案并避免削减其负荷。</li></ol><h4 id="（三）对其他机构及政府部门的建议">（三）对其他机构及政府部门的建议</h4><ol><li>独立系统运营商（Independent System Operator, ISO）/区域输电组织（Regional Transmission Organization, RTO）及公用事业委员会应当设计合理的市场机制，补偿发电机所有者进行机组防冻改造、翻新或设计新机组时的成本。</li><li>在可靠性标准修改完成前的过渡时期，FERC、NERC及区域电力可靠性组织（Regional Entities），应当组织具备应对极寒天气经验的工作人员召开技术研讨会议，就如何提升机组防冻能力开展讨论。</li><li>规划协调机构（Planning Coordinators）应当拟定更准确的冬季系统备用边界计算流程，采用真实的冬季历史峰值负荷进行计算，同时重新考虑极寒天气下，燃气机组与风电机组的真实可用容量。</li><li>输电资产拥有者（Transmission Owners，TO）、输电系统操作员，应当与配电提供商（Distribution Providers，DP）、可靠性协调机构合作，评估并改进所拟定的人工负荷轮停计划。</li><li>州立、联邦与当地责任主体，应当考虑成立紧急事故响应中心，为电–气耦合能源系统应对极端天气事件做好充足准备。</li><li>功率平衡责任主体应当雇用了解天气-负荷间关联的员工，扩大其短期负荷预测的范围，采用多种预测模型、多个气象数据源，考虑区域间差异性及分布式可再生能源影响，提高短期负荷预测的精度。</li><li>ISO/RTO及州立公共事业委员会、立法机关应当设计合理的市场机制，对可在短时间内快速响应的需求侧管理资源，供电短缺时的关键性需求响应资源，提高能源利用效率的措施等进行奖励。</li><li>邻近的可靠性协调机构、功率平衡责任主体以及输电系统操作员，应当进行区域间双向季节性潮流转移的仿真计算；可靠性协调机构、输电系统操作员与配电提供商，应当定期自行开展负荷轮停场景的仿真计算，以便调度员更好地应对极寒天气。</li><li>规划协调机构、输电资产拥有者、输电系统操作员应当与发电机所有者、发电机运行人员进行协商，确保机组延时保护系统与电网低频减载装置之间的协调一致，由区域电力可靠性组织进行检查。</li><li>功率平衡责任主体、可靠性协调机构、输电系统操作员应当完善紧急事故报告机制，缩短发电机所有者、发电机运行人员与输电系统操作员报告发输电故障的时间。</li><li>管理天然气设施的联邦、州立相关机构，应当合作开展研究，如何制定合理的措施进一步保障极寒天气下的天然气供给。</li><li>ERCOT应当开展研究，评估ERCOT区域电网与邻近区域电网之间新建联络线的必要性。</li><li>FERC-NERC-区域电力可靠性组织团队应当开展研究，评估ERCOT在极寒天气条件下黑启动机组的可用性，并与发电机所有者合作研究ERCOT历史上发生的低频事件及重要的频率扰动事件。</li><li>可靠性协调机构、功率平衡责任主体、区域电力可靠性组织、输电系统操作员、输电资产拥有者、配电提供商，以及一个或多个代表美国天然气设施的机构，应当合作研究如何辨识关键的天然气设施负荷，从而更好地应对极寒天气。</li></ol><h4 id="（四）附：其他分析">（四）附：其他分析</h4><p>        回溯整个事件，美国作为经济强国，但只有“世界第三”级别的电网结构。同时，美国电网基础设施建设严重不足，部分政客不断推行新能源发电，但是并网支出分配不均加重开发商负担，导致可再生能源发电装机增速远不及脱碳需求。得州的停电事故，反映了调度机构对于发电机组的可调电力电量评估存在缺陷。</p><p>        同样处于美国中南部地区，SPP和MISO这2个区域电网由于与其他区域电网之间有较强的联络线连接、存在较为充分的功率交换，在此次极寒天气中，电力系统受到的影响较轻；而ERCOT则遭受了沉重的打击。其中一个重要原因是ERCOT仅有略超100万千瓦的直流联络线与外网相连。一正一反两个案例，使跨区电网的作用价值不辩自明。而近年来美国电网面临输电网投资不足、可再生能源消纳困难、电网安全可靠性有待提高等问题。 美国输电网投资不足、建设缓慢。美国输电网投资自上世纪70年代以来一直裹足不前，而且长期滞后于电力需求和发电容量的增长。由于输电投资水平低，跨州、跨区电网联系薄弱，输电能力不足，造成了输电瓶颈， 使拥有廉价电的州无法送至电力缺乏的州，所以美国亟须建设新的输电线路。美国输电网投资不足的原因包括两方面，一是跨州输电项目建设需要多个州的监管部门同意，有时还要多个联邦政府部门同意，审批程序复杂、审批时间长、获得批准难；二是输电项目投资回报低、建设周期长，与其他领域相比缺乏投资吸引力，影响了输电项目建设资金的筹集。</p><p>        ERCOT如果不采取负荷轮停措施，得州或将酿成更大范围的停电事故，而一旦发生大停电，部分黑启动机组由于缺乏天然气燃料，将无法有效发挥黑启动的功能，后果将变得更为严重。这为电力系统的规划、运行提供了启示，即需要适度增加天然气等燃料储备，尤其对于黑启动机组的燃料储备。同时，应适度增加配置长时间储能设施，如季节性储能、氢储能等，以应对极端天气下长时间的容量缺额和电量不足风险。但是除FERC活动外，迄今为止，美国涉及储能的联邦政策已被限制，涉及储能的大多数政策行动都处于州一级。国家一级的政策行动包括制定采购任务、制定激励措施，以及要求将储能纳入长期规划机制。</p><p>        新能源发电方面，《光伏未来研究》报告是美国能源部与美国国家可再生能源实验室共同发布的。其中指出，到2035年，如果要实现95%零碳电网目标的话，美国至少需要10亿千瓦的光伏装机容量；而达成净零排放目标，到2050年美国需要至少 30 亿千瓦的光伏装机。届时，美国光伏产业将满足全国至少 40%的电力供给。2020 年，美国全年实际上仅新增了1500万千瓦光伏装机，截至2020年底，美国累计光伏装机总量仅占全美电力供应总量的3%左右，远不及目标所需。能源互联网的特征之一是不同能源形式之间的深度融合。此次得州的停电事故，揭示了电力系统与天然气系统这2个重要基础设施之间的耦合程度日益加深，亟待研究二者之间深层次相互影响机理。</p><p>        复杂的分布式管理加上美国联邦体制下难以整合形成协调统一的全国性电网。美国实行自由竞争的市场经济体制，美国电网建立在私有化基础上，由不同所有权属的电网逐步互联发展起来，由于输电网产权分散、难以整合，至今难以形成全国性电网。美国联邦政治体制下，各州电网监管权限大，而联邦职责有限， 电网发展主要由各州主导，各州更多从各自利益出发，很难实现从全国能源布局及资源优化配置高度统筹规划电网发展。</p><p>        美国电网经过百年发展，1950年代就基本定型，70年代后得建设投资就已经陷入停滞状态。受制于“散装电网”的州绝不止得州一家，整个美国的电力系统都是分散个体的集合体。此外，市场利润的下滑以及动辄十年的项目审批建设时间都导致了私人企业在供电这个事关国计民生大事上的漠不关心。当然也没有企业愿意关心基础电力设施的维修、完善以及更新等。早在2014年，美国前能源部部长比尔·理查森已经在强调：“如果希望尽快享受到电力多样化的优势，美国必须抓紧整理电网结构，尤其是太阳能和风能。”同时，他也看到中国特高压输电技术这一项超前的输电技术，但是事实上像美国这样以利润最大化作为追求目标，同时牺牲公共风险，这种因为体制原因所带来的一系列问题是无法仅仅通过学习、效仿技术解决的<sup>[18]</sup>。</p><p>        尽管大额花销、政治障碍等问题尚待解决，但改善破旧的电网系统已经势在必行，美国必须坚定地展开行动。就像美国前总统艾森豪威尔大手一挥，发展跨州高速公路一样，华盛顿必须保证国内拥有可靠而高效的电力系统，避免老旧低效的电网成为阻碍美国经济和产业发展的“绊脚石”。由此看来，美国的电网系统还有很长一段路要走。</p><h3 id="八、参考资料">八、参考资料</h3><p>[1] 51878_ERCOT_Letter_re_Preliminary_Report_on_Outage_Causes <a href="https://www.ercot.com/files/docs/2021/04/06/51878_ERCOT_Letter_re_Preliminary_Report_on_Outage_Causes.pdf">https://www.ercot.com/files/docs/2021/04/06/51878_ERCOT_Letter_re_Preliminary_Report_on_Outage_Causes.pdf</a></p><p>[2] 应急管理部办公厅关于印发《生产安全事故调查报告编制指南（试行）》的通知 <a href="https://www.mem.gov.cn/gk/zfxxgkpt/fdzdgknr/202303/t20230316_444990.shtml">https://www.mem.gov.cn/gk/zfxxgkpt/fdzdgknr/202303/t20230316_444990.shtml</a></p><p>[3] 张晓萱,马莉.各自为政的美国电网[J].国家电网,2014(03):74-76.</p><p>[4] ISO/RTO COUNCIL – Coming together to create a smarter &amp; stronger North American power grid <a href="https://isorto.org/">https://isorto.org/</a></p><p>[5] Electric Reliability Council of Texas <a href="https://www.ercot.com/">https://www.ercot.com/</a></p><p>[6] ML11231A769 <a href="https://www.nrc.gov/docs/ML1123/ML11231A769.pdf">https://www.nrc.gov/docs/ML1123/ML11231A769.pdf</a></p><p>[7] 2021-Winter-Storm-Uri-AAR-Findings-Report <a href="https://www.austintexas.gov/sites/default/files/files/HSEM/2021-Winter-Storm-Uri-AAR-Findings-Report.pdf">https://www.austintexas.gov/sites/default/files/files/HSEM/2021-Winter-Storm-Uri-AAR-Findings-Report.pdf</a></p><p>[8] Close to 70 dead in states with severe winter weather: report | The Hill <a href="https://thehill.com/homenews/state-watch/539751-as-temperatures-expected-to-warm-approximately-70-dead-from-severe/">https://thehill.com/homenews/state-watch/539751-as-temperatures-expected-to-warm-approximately-70-dead-from-severe/</a></p><p>[9] Texas water shortage adds to power crisis as new winter storm moves in <a href="https://www.nbcnews.com/news/us-news/texas-contending-water-nightmare-top-power-crisis-n1258208">https://www.nbcnews.com/news/us-news/texas-contending-water-nightmare-top-power-crisis-n1258208</a></p><p>[10] 2021 Texas power crisis - Wikipedia <a href="https://en.wikipedia.org/wiki/2021_Texas_power_crisis">https://en.wikipedia.org/wiki/2021_Texas_power_crisis</a></p><p>[11] Assessment-of-Energy-System-Reliability-Failures-During-the-Extreme-Cold-Weather-Event-in-the-ERCOT-Region-PDF <a href="https://assets.jsheld.com/uploads/Assessment-of-Energy-System-Reliability-Failures-During-the-Extreme-Cold-Weather-Event-in-the-ERCOT-Region-PDF.pdf">https://assets.jsheld.com/uploads/Assessment-of-Energy-System-Reliability-Failures-During-the-Extreme-Cold-Weather-Event-in-the-ERCOT-Region-PDF.pdf</a></p><p>[12] February 2021 Extreme Weather Event <a href="https://www.ercot.com/news/february2021">https://www.ercot.com/news/february2021</a></p><p>[13] Field study shows icing can cost wind turbines up to 80% of power production – ScienceDaily <a href="https://www.sciencedaily.com/releases/2021/03/210304161058.htm">https://www.sciencedaily.com/releases/2021/03/210304161058.htm</a></p><p>[14] The February 2021 Cold Weather Outages in Texas and the South Central United States | FERC, NERC and Regional Entity Staff Report | Federal Energy Regulatory Commission <a href="https://www.ferc.gov/media/february-2021-cold-weather-outages-texas-and-south-central-united-states-ferc-nerc-and">https://www.ferc.gov/media/february-2021-cold-weather-outages-texas-and-south-central-united-states-ferc-nerc-and</a>)</p><p>[16] The freeze in Texas exposes America’s infrastructural failings | The Economist <a href="https://www.economist.com/united-states/2021/02/17/the-freeze-in-texas-exposes-americas-infrastructural-failings">https://www.economist.com/united-states/2021/02/17/the-freeze-in-texas-exposes-americas-infrastructural-failings</a></p><p>[15] Report on outages and curtailments during the Southwest cold weather event <a href="https://cmsstage.ferc.gov/sites/default/files/2020-07/OutagesandCurtailmentsDuringtheSouthwestColdWeatherEventofFebruary1-5-2011.pdf">https://cmsstage.ferc.gov/sites/default/files/2020-07/OutagesandCurtailmentsDuringtheSouthwestColdWeatherEventofFebruary1-5-2011.pdf</a></p><p>[17] The Texas Electric Grid Failure Was a Warm-up – Texas Monthly <a href="https://www.texasmonthly.com/news-politics/texas-electric-grid-failure-warm-up/">https://www.texasmonthly.com/news-politics/texas-electric-grid-failure-warm-up/</a></p><p>[18] 比尔·理查森,王林. 中国特高压——美国电网的救赎[N]. 中国能源报,2014-01-20(009).</p><h3 id="九、后记">九、后记</h3><p>        本次报告的完成，首先需要感谢我的父母，李宇浩、詹逸宝、葛薪茂同学等，他们提供了部分相关想法建议。同时，三峡大学高电压技术教师张文婷以及研究生学长刘伟对于本次报告部分格式和内容的勘误也使本次作业更加完善。再次对能够在五一假期期间阅读并提出建议的有关人士表达衷心的谢意！</p><p>        再者，我想感谢我的电力系统继电保护II课程的任课教师李欣，虽然快速在两三天时间内摸清楚美国的整个电力系统是痴人说梦的，但是通过这次作业，我阅读了很多关于美国电力系统历史的资料。同时，相比于事故调查报告、这份报告更像是事故调查综述。想要了解更多信息可以阅读FERC、NERC以及6所区域可靠性机构（Midwest Reliability Organization, Northeast Power Coordinating Council, ReliabilityFirst Corporation, SERC Corporation, Texas Reliability Entity and Western Electricity Coordinating Council）共同组成的调查委员会于美国当地时间2021年11月16日发布的长达316页的停电事故分析报告（见参考资料第14条）。在官方报告中有细节到电力单元的事故报告，比如4%的故障是由极端低温、冻雨天气直接造成的，31%的故障与发电机组的燃料密切相关。还有21%为与低温相关的机组内部机械系统、电气系统故障，如系统零部件在低温下发生的脆裂；仅有2%的故障是与输配电系统相关的电网侧故障等等关于事故更详细的信息。</p><p>        第二次世界大战结束后，美国的制造业曾经达到近全球制造业的50%。制造业曾经是美国经济的支柱，但近年来面临着许多挑战，如国际竞争、技术变革和全球化等。因此，美国经济逐渐向服务业和科技业等高附加值领域转移。但是近年来美国对于各种产品的金融化、高端化导致轻工业和加工产业，工业产业链不完整，生产加工和一部分工业转移到亚洲。虽然高新技术产业以及服务业全球领先，但是大多数重工业产业空心化，这种整体的产业结构目前来看属于亚健康的状态。美国这种资本导向的国家如果不加强建设基础设施、加快完善整体产业链，那么一旦受到任何外部因素的影响导致高附加值产业削弱，最终叫苦的只能是美国的普通人民。相比之下，中国目前大力发展实体经济，稳健发展金融，要实现国内大循环的战略就是为了规避这种产业结构偏科所造成的风险，创造更多的就业机会的同时不断创新和改进技术，以提高生产效率和产品质量，从而保持竞争力。这种技术进步不仅有利于实体经济本身的发展，也可以带动整个经济的技术进步。在防止经济区域分化和产业集中度过高的同时，为国家的经济发展带来更多机遇和挑战。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 style=&quot;text-align:center;font-weight:700;color:#B399FF&quot;&gt;&lt;em&gt;2021 Texas Power Crisis&lt;/em&gt;&lt;/h2&gt;
&lt;h3 id=&quot;作者前言&quot;&gt;作者前言&lt;/h3&gt;
&lt;p&gt;        该事故调查报告</summary>
      
    
    
    
    <category term="生活中有趣的知识点" scheme="https://www.alexation.cn/categories/%E7%94%9F%E6%B4%BB%E4%B8%AD%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
    <category term="电力系统" scheme="https://www.alexation.cn/tags/%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>2023 ICM Problem Z The Future of the Olympics</title>
    <link href="https://www.alexation.cn/math/model2/"/>
    <id>https://www.alexation.cn/math/model2/</id>
    <published>2023-04-03T10:05:26.000Z</published>
    <updated>2023-09-02T06:09:00.712Z</updated>
    
    <content type="html"><![CDATA[<h2 style="text-align:center;font-weight:700;color:#B399FF"><em>美赛2</em></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 style=&quot;text-align:center;font-weight:700;color:#B399FF&quot;&gt;&lt;em&gt;美赛2&lt;/em&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="数学建模" scheme="https://www.alexation.cn/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="ICM" scheme="https://www.alexation.cn/tags/ICM/"/>
    
  </entry>
  
  <entry>
    <title>2023 MCM Problem C Predicting Wordle Results</title>
    <link href="https://www.alexation.cn/math/model1/"/>
    <id>https://www.alexation.cn/math/model1/</id>
    <published>2023-02-06T10:05:26.000Z</published>
    <updated>2023-09-02T06:09:28.462Z</updated>
    
    <content type="html"><![CDATA[<h2 style="text-align:center;font-weight:700;color:#B399FF"><em>美赛</em></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 style=&quot;text-align:center;font-weight:700;color:#B399FF&quot;&gt;&lt;em&gt;美赛&lt;/em&gt;&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="数学建模" scheme="https://www.alexation.cn/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="MCM" scheme="https://www.alexation.cn/tags/MCM/"/>
    
  </entry>
  
  <entry>
    <title>SEO到网站优化排名</title>
    <link href="https://www.alexation.cn/other/seo/"/>
    <id>https://www.alexation.cn/other/seo/</id>
    <published>2022-12-06T10:05:26.000Z</published>
    <updated>2022-12-08T01:40:32.853Z</updated>
    
    <content type="html"><![CDATA[<h2 style="text-align:center;font-weight:700;color:#B399FF"><em>SEO</em></h2><p>SEO： Search Engine Optimization, 搜索引擎优化。利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是让其在行业内占据领先地位，获得品牌收益。很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移。SEO是提高你网站排名的一个很有效的方法，这个完善和优化你网站的排名因素的方法就是能影响搜索引擎的排名的算法。 因此，SEO是网络营销策略 （online marketing Digital strategy）和数字营销策略 （Digital Marketing strategy）中很重要的一个环节。SEO使你的网站获取得更多的流量（traffic）同时也可以提高你在搜索引擎的排名。那就意味你可以获取得更多的订单，更多的利润。</p><p><a href="https://chuhaiyi.baidu.com/news/detail/45983037">Google 和 Yandex 之间的主要区别是什么？ (baidu.com)</a></p><p>排名分数-考试-标准答案-算法</p><p>游戏规则-（包括自媒体、b站、知乎发布文章等）</p><p>数据分析（核心）</p><ol><li><p>放出蜘蛛（代码</p></li><li><p>蜘蛛来访抓取</p></li><li><p>页面收录（索引</p></li><li><p>算法计算分数</p></li><li><p>排名</p></li><li><p>链接的长度 （中文英文）</p></li><li><p>网站识别回访（打开速度、识别难度）</p></li><li><p>有效收录</p></li><li><p>访问日志</p></li></ol><p>权重值、用户存留、提高质量、追求高指数关键词的排名</p><p>选择关键词</p><ul><li>指数</li><li>相关结果</li><li>广告位</li><li>首页数量</li></ul><p>做SEO的目的当然是为了销售，所以在这个角度看，SEO也算是付款营销的一种手段。不过SEO不想广告那样的直接能立马见效。SEO更像是一个细水长流的积累过程，效果不会立竿见影。但SEO胜在稳定和投入较少。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 style=&quot;text-align:center;font-weight:700;color:#B399FF&quot;&gt;&lt;em&gt;SEO&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;SEO： Search Engine Optimization, 搜索引擎优化。利用搜索引擎的规则提高网站在有关搜索引</summary>
      
    
    
    
    <category term="生活中有趣的知识点" scheme="https://www.alexation.cn/categories/%E7%94%9F%E6%B4%BB%E4%B8%AD%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
    <category term="SEO" scheme="https://www.alexation.cn/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>PS速成记录</title>
    <link href="https://www.alexation.cn/other/ps/"/>
    <id>https://www.alexation.cn/other/ps/</id>
    <published>2022-11-25T02:05:26.000Z</published>
    <updated>2022-12-06T13:14:20.801Z</updated>
    
    <content type="html"><![CDATA[<h2 style="text-align:center;font-weight:700;color:#B399FF"><em>PS is just a tool</em></h2><h2 id="前言">前言</h2><p>略</p><h2 id="学习网址">学习网址</h2><p><a href="http://99ut.blueidea.com/">大师之路 Unify tutorial (blueidea.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 style=&quot;text-align:center;font-weight:700;color:#B399FF&quot;&gt;&lt;em&gt;PS is just a tool&lt;/em&gt;&lt;/h2&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;h2 id=&quot;学习网址&quot;&gt;学习网址&lt;</summary>
      
    
    
    
    <category term="TOOLS" scheme="https://www.alexation.cn/categories/TOOLS/"/>
    
    
    <category term="PS" scheme="https://www.alexation.cn/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>ABOUT CSGO</title>
    <link href="https://www.alexation.cn/game/csgo/"/>
    <id>https://www.alexation.cn/game/csgo/</id>
    <published>2022-09-07T16:05:30.000Z</published>
    <updated>2023-09-02T06:23:56.712Z</updated>
    
    <content type="html"><![CDATA[<h2 style="text-align:center;font-weight:700;color:#B399FF"><em>安装只需要20个G、却需要一生来精通</em></h2><h2 id="前言">前言</h2><p>我其实是一个要求比较高的boy，这不仅仅体现在学习生活情感上，游戏也是一样的，目前市场上的主流游戏并不能让我找到游戏的感觉，我听到的不过是舍友比赛失败时的吐槽或沉默、胜利的欢呼与感动，但就是这些单纯的情感上的变化、包括肉体上的激动对我而言却非常难。也可能是我个人的性格的关系，导致我对大部分游戏其实是没有很大兴趣的，但2022年6月份CSGO的一场残局改变了我对CSGO的态度。拿下加时赛赛点残局的那一刻、队友疯掉了，我沉默了，我知道，CSGO的种子已经埋下。</p><p>本来写这篇文章的初心是做一次学习记录希望给萌新些指导，Emm好像也没人看哈哈哈哈，所以我打算就把我个人看到、听到、学到的一些心得体会写下来，也是本网站的初心。希望刚入门的你找到自己的Training System，老玩家也能收获到自己的Inspiration，那我这篇文章也就完成任务啦！</p><p><font style="font-weight:700;color:#B399FF">这里首先感谢我学习过程中两个重要引路人，大部分的游戏思路也来自哲学老师，还包括一些哲学上的理解。</font></p><ul><li><p>哲学老师yyds <span class="emoji" alias="stuck_out_tongue_closed_eyes" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8">😝</span></p><p><a href="https://space.bilibili.com/388255703/video">CSGO哲学老师的个人空间_哔哩哔哩_bilibili</a></p></li><li><p>我的初中同桌<span class="emoji" alias="kissing_heart" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f618.png?v8">😘</span></p><p><a href="https://space.bilibili.com/399031758/?spm_id_from=333.999.0.0">冰美式队长CSGO的个人空间_哔哩哔哩_bilibili</a></p></li></ul><h2 id="一、规则与策略（Rule-and-Strategy）">一、规则与策略（Rule and Strategy）</h2><p>Game这个词都不陌生，正常我们能想到的就是“游戏”，但是Google Translate给出的翻译是</p><blockquote><p>a form of play or sport, especially a competitive one played according to rules and decided by skill, strength, or luck<br>（一种比赛或运动的形式，尤指按照规则进行的比赛，由技巧、力量或运气决定）</p></blockquote><p>Game是一种<strong>形式</strong>，并且按照<strong>规则</strong>进行。外国人更看重的是博弈、是规则。一切的游戏本质上都是博弈，只不过形式不同罢了，比如在CSGO中枪械由你决定，使用方式也是你决定的，策略更是整个团队决定的，但是我们每个人都无法决定规则，这一切的决择、策略、博弈，全部是根据当下的Rule所可能产生的一切概率事件。</p><h3 id="1、游戏规则（Game-Rule）">1、游戏规则（Game Rule）</h3><p>游戏规则是30个回合，上下半场交换CT与T，赢下16回合即胜利。T安装C4并爆炸或打掉对面全队可胜利、而CT要阻止C4爆炸或者打掉对面全队即胜利、时间耗尽CT胜利。C4从安装到爆炸需要45秒，CT拆弹需要10秒，而在有拆弹器的情况只需要5秒。如果比赛双方队伍实力悬殊较小，就会出现比分15:15的平局情况，通常这会要求比赛双方进入加时赛阶段。加时赛开始时，总局数会增加6局，每个人的经济会被重置为$10000，3局比赛之后，会在第4局换边，经济将再被重置为$10000。此时只需再赢得4局比赛胜利即为胜出者。如果仍然平局，则可能会继续进入加时阶段。</p><h4 id="1-经济">1.经济</h4><p>CSGO和其他FPS游戏的主要区别之一就是经济系统。也因此诞生了更多的可玩性，比赛也有了更多的看点，包括ECO翻盘、残局策略等。一般可以通过击杀对手、安装或拆除C4、赢得回合胜利获取金钱，或者在回合失败前死亡获得补偿。随着对游戏理解的深入，对经济系统的理解也逐步深入。</p><h5 id="1-经济系统">1.经济系统</h5><ul><li><p>起始经济为800。</p></li><li><p>赢下一局：</p><p>击杀所有敌人+3250，拆除炸弹+3500，炸弹爆炸+3500</p></li><li><p>输掉一局：</p><p>根据失败点（也叫战败补偿）增加下一局经济：（零格：1400、一格：1900、两格：2400、三格：2900、四格：3400）。匪徒埋包后被拆除多800。若时间用尽，存活匪徒不加经济</p></li></ul><p><img src="https://s2.loli.net/2022/09/08/M2KtCdnlRzVIrOG.png" alt=""></p><h5 id="2-常见道具花费">2.常见道具花费</h5><ul><li><p>警察枪械道具</p><ul><li>燃烧弹 = 600，钳子 = 400</li><li>小甲 + M4 + 烟 + 闪 + 闪 = 4450</li><li>小甲 + M4 + 烟 + 闪 + 闪 + 火 = 5050</li><li>小甲 + AUG + 烟 + 闪 + 闪 + 火 = 5250</li><li>小甲 + AWP + 烟+ 闪 + 闪 = 6100</li></ul></li><li><p>匪徒枪械道具</p><ul><li>燃烧弹 = 400</li><li>大甲 + AK + 烟 + 闪 + 闪 = 4400</li><li>大甲 + AWP + 烟 + 闪 = 6250</li></ul></li></ul><h4 id="2-枪械">2.枪械</h4><p>每种枪的价格和击杀收益是不一样的。每种枪的属性也是不同。属性主要包括：子弹数量、弹夹数量、普通威力、护甲穿透力、伤害衰减、稳定性和移速。</p><p>举个例子，USP威力大于格洛克，且伤害衰减低，所以无论远近只要一枪头就会击杀，而格洛克中远距离需要两枪头。所以USP弹量少且弹夹少，以此平衡。当你连续开火时，AK47弹道稳定性并不是很理想，但是AK47护甲穿透高、威力大、伤害高，无论远近是否有头盔都是一枪头。枪械的选择需要综合考虑队伍的经济、队友的装备、武器的特点等。</p><p>而当你死亡时，你背包里价值最高的武器和投掷物会掉落，如果你是CT，你购买的拆弹器（一个打开的包袱）也会掉落。这些都可以拾取，但是一个人至多可以携带四个投掷物 并且只有闪光弹可以带两个，死亡后只会掉落一个投掷物。这投掷物不是最贵的，而是你死亡前最后切换的投掷物。死亡后复活的下一局，只有一把手枪，所有武器道具需要重新购买。</p><h4 id="3-身法">3.身法</h4><p>关于移速，切刀跑最快，其他都有所不同，一般速度从快到慢是持刀、持投掷物、持手枪、持主武器。比如蹲跳可以跳更高，跳蹲比蹲跳还稍微高一些。有兴趣还可以接触旋转跳、连跳等身法，当然，身法只是起辅助作用，重要的还是枪法以及思路。</p><p>道具的投掷也和身法有关。包括左键、右键、双键投掷，不同的方向、速度的投掷也不一样。每个地图都有很多道具投掷技巧，于是可以听到封警家、VIP火等等，就是道具扔到相应地点。这个和枪法都很重要。</p><h4 id="4-话术">4.话术</h4><p>急停、跑打、连发、压枪。其实就是正常FPS游戏操作，但是因为CSGO高操作性，先停下来瞄准再开火，用最少的子弹最快击杀才是正道，所以不要跑打，学会急停、连发、压枪。压枪弹道每种武器都不一样，需要自己训练。跑打除非脸贴脸，否则满屏幕乱飘子弹。</p><p>单向烟、单向火，指对一方有利的道具。只会遮挡一方视野，火同理。</p><h3 id="2、博弈要素（Game-elements）">2、博弈要素（Game elements）</h3><p>“会思考才会进步”，打游戏就和下棋一样，本质是一场博弈。这些要素共同决定了游戏的胜利与失败。更多的是对信息（information）的索取、更多的是人数上的交换（trade kill）。</p><h4 id="1、参与者-PLAYERS-理性选择的主体">1、参与者(PLAYERS)理性选择的主体</h4><ol><li>就团队而言:防守方CT(默认被动)，进攻方T(默认主动)</li><li>就选手个人而言:队友，对手</li></ol><h4 id="2、信息-INFORMATION-有意义的内容">2、信息(INFORMATION)有意义的内容</h4><ol><li>道具信息:控制地图，道具数量，人数</li><li>声音信息:对手具体位置，枪械，进攻防守动向</li><li>经济信息:枪械配置，采取的策略(eco、anti-eco、AWP)</li><li>时间信息:道具时间，进攻与防守时间</li><li>人数信息:人数的多少，优势劣势</li></ol><h4 id="3、行动-ACTION-参与者能够选择的变量">3、行动(ACTION)参与者能够选择的变量</h4><ol><li>控制地图(map control)</li><li>反清(retake)</li><li>补防转点(rotate)</li><li>激进(aggressive)找人头、找首杀</li><li>保守(passive)交叉火力</li><li>进攻包点、回防、保枪、playtime</li></ol><h4 id="4、策略-STRATEGIES-参与者在行动之前所准备好的一套完整的行动方案">4、策略(STRATEGIES)参与者在行动之前所准备好的一套完整的行动方案</h4><ol><li>个人技巧:身法走位，预瞄，交换道具，拼抢补枪</li><li>两两小配合:交叉火力，一个打一个藏，道具配合，双摸</li><li>控制地图的团队设定（默认)∶控图顺序，道具顺序</li></ol><p><strong>整个博弈中，策略建立起了从信息到行动的关系，参与者首先选择的是策略，然后才是根据最新的信息作出行动的选择</strong></p><h4 id="5、损益-PAYOFF-参与者的得与失">5、损益(PAYOFF)参与者的得与失</h4><ul><li>人数损益</li><li>地图损益</li><li>道具损益</li><li>经济损益</li><li>时间损益</li></ul><h4 id="6、结局-OUTCOME">6、结局(OUTCOME)</h4><p>参与者选择了各自的策略及其相应的行动以后的结果</p><h4 id="7、均衡-EQUILIBRIUM">7、均衡(EQUILIBRIUM)</h4><p>是指所有博弈的参与者的最优策略组合，特指某类结局，在该类结局中，参与者已经无法通过改变自身的策略及其行为选择来增加收益</p><h4 id="8、博弈的规则-RULES-OF-THE-GAME">8、博弈的规则(RULES OF THE GAME)</h4><p>规则是一种限制，决定了参与者的策略(行动）选择，并最终决定了博弈的结果。</p><ul><li>游戏内:子弹时间，道具量，单局时间，埋包机制，枪械特性，人物移动特性等等</li><li>游戏外:游戏内角色分工，个人价值决定，工资奖惩制度，个人利益与团队利益的平衡</li></ul><h2 id="二、基础设置（Basic-Setting）">二、基础设置（Basic Setting）</h2><h3 id="1-硬件外设">1.硬件外设</h3><p>耳机、麦、屏幕、键鼠都要备好，CSGO还是很吃外设的。当然是越好越有利于比赛发挥，当然，实力足够的情况下可以暂时忽略。</p><h3 id="2-软件参数">2.软件参数</h3><blockquote><p>存在即合理。职业自有成为职业的理由，职业的参数设置也有存在的理由，找到适合自己的即可。</p></blockquote><p>软件参数包括屏幕显示比例、鼠标EPDI、大跳、跳投、投掷物的按键绑定，还有部分HUD显示的个性化。</p><p>如何找到适合自己的EDPI？当利用A/D进行左右急停的时候，同时鼠标左右摆动，准星能够维持在同一个点上，在此EDPI进行微调即可。</p><h2 id="三、枪法（Training）">三、枪法（Training）</h2><h3 id="1-定位-と-急停">1.定位 と 急停</h3><p>我是首先练习定位和急停这两项，最开始通过training_aim_csgo以及Aim_botz两张图结合老师的训练表来练习。注意，我们不要做数据党，我们的目的是训练瞄准能力，尽量提高准确度以及正确率，少空枪才能真正的提高技术。如果第一次接触的话可以试着放慢速度，但是熟悉之后一定要提高要求，在准确度保证的前提下，提高速度，提高分数。加油！</p><p><img src="https://s2.loli.net/2022/08/09/Ai4Q15mPsNEST2O.png" alt="training_aim_csgo"></p><p><img src="https://s2.loli.net/2022/08/10/BCgM9NVusQUKE4P.png" alt="Aim_botz"></p><p><img src="https://s2.loli.net/2022/09/08/wqQIH1A4fx83Mza.png" alt="训练表"></p><p>在练习上面的同时可以结合Aim Lab同时训练（Steam）。</p><p>《目标实验室》我着重练习的两个项目是SIXSHOT(ULTIMATE)以及MULTISHOT(ULTIMATE)。分别是六目标训练和多目标训练。六目标训练考验的是对于鼠标的精准定位能力以及路线的合理优化；多目标训练考验的是对于不确定位置的反应速度以及粗略定位能力（其实这个也涉及路线的合理优化）</p><p><img src="https://s2.loli.net/2022/08/10/oJTjF8OmitCpIwd.png" alt="SIXSHOT(ULTIMATE)"></p><p><img src="https://s2.loli.net/2022/08/10/AcOipPzgfn8qoQ9.png" alt="MULTISHOT(ULTIMATE)"></p><p>目前所能接触到的最高分分别是：SIXSHOT(ULTIMATE)：10.5w；MULTISHOT(ULTIMATE)：11.3w；每天拿这个热身真的超级Niceeee！<span class="emoji" alias="stuck_out_tongue_closed_eyes" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8">😝</span></p><h3 id="2-压枪">2.压枪</h3><p>推荐Recoil Master这个图，可以针对子弹的位置做统计。结合训练表的压枪方式进行训练，能够提高作战能力，残局能力。基本功要打扎实！</p><p><img src="https://s2.loli.net/2022/08/10/gUvzmAqCuSI5Baf.png" alt="Recoil Master"></p><h2 id="四、地图理解（Map-Comprehension）">四、地图理解（Map Comprehension）</h2><p>跑图！只有真正自己去跑图才会发现平时注意不到的问题，比如两地之间的移动时间决定了丢闪的时间，一些道具的Time与地图的结合。队友的状态和地图的结合。</p><h3 id="1-预瞄">1.预瞄</h3><p>推荐Yprac系列，走几遍熟悉常规CT点，随着枪法的提升，点位的熟悉便可以调到100、50血每人。</p><h3 id="2-道具">2.道具</h3><p>相同点位不同位置的丢法，不同时间丢的决策，都是要结合地图以及局势信息来决定的。和前文的博弈相同，在训练中熟悉，在实战中进步。不断提高自己的地图理解才能为团队带来胜利。</p><h2 id="五、总结（Summary）">五、总结（Summary）</h2><p>成长的道路并不总是一帆风顺的，我们需要注意避免陷入“刻意认真”的陷阱。学霸之所以成为学霸不是因为其一味地重复练习（当然这必不可少），而是因为其强大的分析局势的能力，学霸只需要在特定的时间做特定的动作便可以将整个团队胜利的概率提高到最大。所以我想说的是努力固然重要，技巧同样必不可少。获取技巧的最好办法就是模仿！我们是站在巨人的肩膀上的，创新来源于模仿。真正的模仿是理解“为什么”，看到模仿的本质，而不仅仅是表象，这才是后期超越的关键。</p><p>需要注意的是刻意认真和刻意练习不同！前者是指以战术的勤奋，掩盖战略的懒惰，过于注重细节，反而打乱自己的节奏，忽视整体的发展变化，后者是指在面对新情况的时候，能够快速调出过去的一些认知模块，从而在思考和解决问题上有更高效的方法。最初我进行的是最简单的机器人练习，练习的项目很多，包括定位、急停、拉枪、跟枪，练到一定程度的时候进行真人练习。在我们练习的时候，可能会有分数反馈，我们需要注意的是不要过度关注分数的高低，我们需要关注的是在你定位的过程中的动作是否干净利落了些？在你跟枪的时候动作是否更加流畅了些？如果过分在意分数我们可能会进入新手膨胀期，也就是完成特定领域的任务时个体对自己的能力作出不准确的评价的现象——能力低者会高估自己的能力，甚至显著超过平均水平，能力高者会低估自己的能力。下图的达克效应很好地说明了这一点。</p><p><img src="https://s3.uuu.ovh/imgs/2022/11/28/422fcd644432a7bb.png" alt="达克效应"></p><p>如果说正确的自我认知是充分发挥个人作用的催化剂，那么合适的团队意识就是打开成功大门的钥匙。就像《排球少年》里面的乌野队一样，我们不是孤独的王者，我们也不是落寞的豪强、不会飞的乌鸦，我们是一个团队。单打独斗做不成大事，现在，当人们害怕的时候，我们很容易愤世嫉俗，说你们别管我、别管我家、别管或像我一样，思考祈祷的人，但我们要度过这段困难时期。那我们就得团结起来。王牌不是利用自己强大的能力而得到的统治力的那个人，而是即使在没有聚光灯的照耀下也能够发挥自己最大的作用，充分相信队友，冷静地分析形势，从而为整个团队带来胜利的那个人。</p><p>最后，我想给看到这里的读者以及我自己一些建议。</p><ul><li>第一点，不要害怕。一个从不犯错误的人，一定从来没有尝试过任何新鲜事物。我们都曾经历过困难时期，考试考砸、投资失败、天灾人祸、社会的动荡不安、历史时期的五四运动、长征、文化大革命、包括20年的新冠疫情…但每一次经历之后，我们都变得更加强大，通常是因为像我们这样的新一代年轻人，从过去的错误中学习，思考如何变得更好。</li><li>第二点，做你认为正确的事。做那些感觉好、方便、简便的事情。我希望你能坚持自己的价值观，诚实、勤奋、负责、公平、慷慨、尊重他人，你不可能每次都做对，你会像我一样犯错误，但如果你听从内心的真理，即使很难，即使不方便，他们终会注意到你，你将成为焦点，你将成为解决问题的人，而不是产生问题的人。</li></ul><p>随着游戏时间的增长、对游戏理解的深入、我也会不断地补充这篇文章，也欢迎大家随时补充。</p><p><font style="font-weight:700;color:#B399FF">感谢队友以及UP主们提供这些思路，让我能够少走弯路，我也不断地在反思自己的策略，完善个人能力，我在和你一起努力。</font></p><p><font style="font-weight:700;color:#B399FF">最后，很高兴通过CSGO认识你</font> <span class="emoji" alias="wink" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8">😉</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 style=&quot;text-align:center;font-weight:700;color:#B399FF&quot;&gt;&lt;em&gt;安装只需要20个G、却需要一生来精通&lt;/em&gt;&lt;/h2&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我其实是一个要求比较高的boy，这不仅仅体现在学</summary>
      
    
    
    
    <category term="GAME" scheme="https://www.alexation.cn/categories/GAME/"/>
    
    
    <category term="CSGO" scheme="https://www.alexation.cn/tags/CSGO/"/>
    
  </entry>
  
  <entry>
    <title>远程控制空调物联网项目</title>
    <link href="https://www.alexation.cn/contest/AirWifi/"/>
    <id>https://www.alexation.cn/contest/AirWifi/</id>
    <published>2022-08-04T02:05:30.000Z</published>
    <updated>2022-08-04T02:48:26.973Z</updated>
    
    <content type="html"><![CDATA[<p>其实这个项目起源于同学不经意间的一句话——“要是能远程开空调就好了，这样回宿舍的时候总是凉快的！”</p><p>我回——“预算多少”（不是</p><p>因为手上的芯片不多了，STM丢光了，MSP430又不大会用，正好手上一块电赛剩来的K210，而且库封装也很友善，就打算用这个做主芯片来着手写一下这个项目。</p><h2 id="红外发射模块">红外发射模块</h2><p><img src="https://s2.loli.net/2022/08/04/y5jwDkXE6BHY13Z.png" alt=""></p><p>既然要实现空调的开关、定时等相关功能，红外发射模块是必不可少的，网上也有很多这样的模块，包括上位机店家也写好了，真是好不方便。我用的就是上图这一种，非常简洁、四针串口，也会给相关使用说明、硬件的规格手册等：</p><p><a href="https://ctgu.site:8003/index.php/s/TfwzeSTkn63dAFy" style="font-weight:700;color:#B399FF"><em>红外学习模块使用说明书</em></a></p><p><a href="https://ctgu.site:8003/index.php/s/rXDszsA5YgTJfEG" style="font-weight:700;color:#B399FF"><em>红外发射管-TSAL6400</em></a></p><p><img src="https://s2.loli.net/2022/08/04/t1aKoWEzbV2I7Tx.png" alt=""></p><p>使用手册中会有这种协议介绍，我们只需要按照固定的协议以及使用手册中特定的功能码串口传输数据即可。</p><h2 id="语音识别模块">语音识别模块</h2><p><img src="https://s2.loli.net/2022/08/04/7KJUdeBWo948vER.png" alt=""></p><p>语音识别模块我选择的是智家物联的SU-03T核心板，SU-03T 是一款低成本、低功耗、小体积的离线语音识别模组，能快速应用于智能家 居，各类智能小家电，86 盒，玩具，灯具等需要语音操控的产品。店家已经焊好PCB封装，接线方便</p><ul><li>32bit RISC 内核，运行频率 240M</li><li>支持 DSP 指令集以及 FPU 浮点运算单元</li><li>FFT 加速器：最大支持 1024 点复数 FFT/IFFT 运算，或者是 2048 点的实数 FFT/IFFT 运算</li><li>内置高速 SRAM，内置 2MB FLASH</li><li>内置 3W、单声道 AB 类功放</li><li>支持 1 路驻极体麦</li><li>支 持 I2S input/output</li><li>支持 5V 电源输入</li><li>内置 5V 转 3.3V，3.3V 外部负载不超过 150mA</li><li>RC 12MHz 时钟源和 PLL 锁相环时钟源</li><li>内 置 POR（Power on Reset），低电压检测和看门狗</li><li>所 有 GPIO 均可配置为外部中断输入和唤醒源</li><li>1 个标准 SPI Master 接口，最高速率 30MHz</li><li>1 个 SPI Slave 接口最高速率 30MHz</li><li>1 个全双工 UART 最高速率 3Mbps。</li><li>1 个 I2C 主/从控制器最高速率 400kHz</li><li>2 个 PWM 输出</li><li>1 个 12-bit SAR-ADC 最大 450Khz 采样率</li></ul><p>最最最最最重要的是！这个支持UI编程：</p><p><a href="http://www.smartpi.cn" style="font-weight:700;color:#B399FF"><em>智能公元/AIOT快速产品化平台</em></a></p><p>本来想只用这个实现远程控制+语音控制，但可惜只有一个UART，只好采用其他芯片。</p><h2 id="主芯片">主芯片</h2><p>其实打算用K210的时候很纠结的，因为这个板子功耗还是不低的，但我看中了他的库开发以及简介性，毕竟与其调硬件底层、我更喜欢写业务逻辑。（报错也是真的不好改<span class="emoji" alias="cry" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span></p><h3 id="语音识别">语音识别</h3><p>语音识别其实就是三个脉冲，UI编程的话很好设置，K210接受到后向红外串口发送信号，即可实现语音控制空调。</p><h3 id="MQTT通讯">MQTT通讯</h3><p>为了让K210与路由器进行连接，还需串口连接ESP8826，通讯方式选择MQTT。</p><p>当服务器和客户端建立起连接时，就可以相互通信了。在互联网应用大多使用 WebSocket 接口来传输数据。而在物联网应用中，常常出现这样的情况：海量的传感器，需要时刻保持在线，传输数据量非常低，有着大量用户使用。如果仍然使用 socket 作为通信，那么服务器的压力和通讯框架的设计随着数量的上升将变得异常复杂！ 那么有无一个框架协议来解决这个问题呢，答案是有的。那就是 MQTT(消息队列遥测传输)。</p><p>MQTT 是 IBM 于 1999 年提出的，和 HTTP 一样属于应用层，它工作在 TCP/IP 239 协议族上，通常还会调用 socket 接口。是一个基于客户端-服务器的消息发布/订 阅传输协议。其特点是协议是轻量、简单、开放和易于实现的，这些特点使它适 用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M） 通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、 智能家居、及一些小型化设备中已广泛使用。 总结下来 MQTT 有如下特性/优势： ➢ 异步消息协议 ➢ 面向长连接 ➢ 双向数据传输 ➢ 协议轻量级 ➢ 被动数据获取</p><p><img src="https://s2.loli.net/2022/08/04/3Wzf6UkpEmCFrMx.png" alt="MQTT流程图"></p><h3 id="源代码">源代码</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import network,timefrom machine import UART,Timerfrom Maix import GPIOfrom fpioa_manager import fmfrom simple import MQTTClient# User and PasswordSSID&#x3D;&#39;xxxxxxxx&#39; # WiFi 账号KEY&#x3D;&#39;xxxxxxxx&#39;  # WiFi 密码# Mic Control Initfm.register(10, fm.fpioa.GPIOHS4, force&#x3D;True)fm.register(31, fm.fpioa.GPIOHS5, force&#x3D;True)fm.register(30, fm.fpioa.GPIOHS6, force&#x3D;True)open_air &#x3D; GPIO(GPIO.GPIOHS4, GPIO.IN)close_air &#x3D; GPIO(GPIO.GPIOHS5, GPIO.IN)time_air &#x3D; GPIO(GPIO.GPIOHS6, GPIO.IN)# Wifi En Pinfm.register(11, fm.fpioa.GPIOHS0, force&#x3D;True)wifi_en&#x3D;GPIO(GPIO.GPIOHS0, GPIO.OUT)# Wifi Initfm.register(7, fm.fpioa.UART2_TX, force&#x3D;True)fm.register(6, fm.fpioa.UART2_RX, force&#x3D;True)uart_wifi &#x3D; UART(UART.UART2,115200,timeout&#x3D;1000,read_buf_len&#x3D;4096)# Red Initfm.register(9, fm.fpioa.UART1_TX, force&#x3D;True)fm.register(32, fm.fpioa.UART1_RX, force&#x3D;True)uart_red &#x3D; UART(UART.UART1,115200,timeout&#x3D;1000,read_buf_len&#x3D;4096)# WiFidef wifi_enable(en):    global wifi_en    wifi_en.value(en)def wifi_init():    global uart_wifi    wifi_enable(0)    time.sleep_ms(200)    wifi_enable(1)    time.sleep(2)    uart_wifi &#x3D; UART(UART.UART2,115200,timeout&#x3D;1000, read_buf_len&#x3D;4096)    tmp &#x3D; uart_wifi.read()    uart_wifi.write(&quot;AT+UART_CUR&#x3D;921600,8,1,0,0\r\n&quot;)    print(uart_wifi.read())    # important! baudrate too low or read_buf_len too small will loose data    uart_wifi &#x3D; UART(UART.UART2,921600,timeout&#x3D;1000, read_buf_len&#x3D;10240)    uart_wifi.write(&quot;AT\r\n&quot;)    tmp &#x3D; uart_wifi.read()    print(tmp)    if not tmp.endswith(&quot;OK\r\n&quot;):        print(&quot;reset fail&quot;)        return None    try:        nic &#x3D; network.ESP8285(uart_wifi)    except Exception:        return None    return nicdef MQTT_callback(topic, msg):    global uart_red    print(&#39;topic: &#123;&#125;&#39;.format(topic))    print(&#39;msg: &#123;&#125;&#39;.format(msg))    if msg &#x3D;&#x3D; b&#39;open&#39;:        uart_red.write(b&#39;\x68\x08\x00\xFF\x12\x01\x12\x16&#39;)    if msg &#x3D;&#x3D; b&#39;close&#39;:        uart_red.write(b&#39;\x68\x08\x00\xFF\x12\x00\x11\x16&#39;)    if msg &#x3D;&#x3D; b&#39;time&#39;:        uart_red.write(b&#39;\x68\x08\x00\xFF\x12\x02\x13\x16&#39;)        def MQTT_Rev(tim):    try:        client.check_msg()    except OSError:        pass# Connectingwlan &#x3D; wifi_init()wlan.connect(SSID,KEY)print(wlan.ifconfig())# Mqtt ParamsSERVER &#x3D; &#39;xxxxxxxx&#39;PORT &#x3D; 1883CLIENT_ID &#x3D; &#39;xxxxxxxx&#39;USER &#x3D; &#39;xxxxxxxx&#39;PASSWORD &#x3D; &#39;xxxxxxxx&#39;TOPIC &#x3D; &#39;xxxxxxxx&#39;client &#x3D; MQTTClient(CLIENT_ID, SERVER, PORT,user&#x3D;USER, password&#x3D;PASSWORD)client.set_callback(MQTT_callback)client.connect()client.subscribe(TOPIC)tim &#x3D; Timer(Timer.TIMER0, Timer.CHANNEL0, mode&#x3D;Timer.MODE_PERIODIC,period&#x3D;300, callback&#x3D;MQTT_Rev)t_before &#x3D; time.time()while True:    # Reconnecting    if time.time() - t_before &gt; 60:        # Disconnecting        client.disconnect()        tim.deinit()        # Connecting        wlan &#x3D; wifi_init()        wlan.connect(SSID,KEY)        print(wlan.ifconfig())        # Mqtt Params        SERVER &#x3D; &#39;xxxxxxxx&#39;        PORT &#x3D; 1883        CLIENT_ID &#x3D; &#39;xxxxxxxx&#39;        USER &#x3D; &#39;xxxxxxxx&#39;        PASSWORD &#x3D; &#39;xxxxxxxx&#39;        TOPIC &#x3D; &#39;xxxxxxxx&#39;        client &#x3D; MQTTClient(CLIENT_ID, SERVER, PORT,user&#x3D;USER, password&#x3D;PASSWORD)        client.set_callback(MQTT_callback)        client.connect()        client.subscribe(TOPIC)        tim &#x3D; Timer(Timer.TIMER0, Timer.CHANNEL0, mode&#x3D;Timer.MODE_PERIODIC,period&#x3D;300, callback&#x3D;MQTT_Rev)        t_before &#x3D; time.time()    # Mic    if open_air.value() &#x3D;&#x3D; 1:        uart_red.write(b&#39;\x68\x08\x00\xFF\x12\x01\x12\x16&#39;)        time.sleep(1)     if close_air.value() &#x3D;&#x3D; 1:        uart_red.write(b&#39;\x68\x08\x00\xFF\x12\x00\x11\x16&#39;)        time.sleep(1)    if time_air.value() &#x3D;&#x3D; 1:        uart_red.write(b&#39;\x68\x08\x00\xFF\x12\x02\x13\x16&#39;)        time.sleep(1)            time.sleep(0.2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小程序前端">小程序前端</h2><p>MQTT服务器我选择的是环信即时通讯云</p><p><a href="https://docs-im.easemob.com/mqtt/intro">产品概述 IM 开发文档] (easemob.com)</a></p><p>该服务说明比较详细，快速收发demo也比较全，支持服务器端集成SDK、提供API接口，我好爱。<span class="emoji" alias="heart_eyes" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8">😍</span></p><p>收发demo云端我选择的是小程序收发，安装他介绍的操作步骤，补充api参数，初始化代码即可实现订阅功能。这里不做介绍啦。</p><h2 id="补充">补充</h2><p>这个项目其实也没有考虑很多，随便写一些罢了，不过，这里有很多有趣的还可以补充，像：</p><ol><li>你可以通过对接QQ机器人、微信机器人，实现QQ、微信发消息控制智能家居；</li><li>微信、QQ消息通过小爱同学播报；</li><li>通过人脸识别、人体检测，搭配任意摄像机，实现回家欢迎、出门关灯等操作；</li><li>让灯光颜色根据你电脑屏幕颜色来自动变化；</li><li>家里门打开了自动启动XXX游戏；</li><li>……………</li></ol>]]></content>
    
    
    <summary type="html">本项目可以通过微信小程序、语音等方式实现远程、语音控制宿舍空调的开关以及定时等相关功能。</summary>
    
    
    
    <category term="物联网" scheme="https://www.alexation.cn/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
    <category term="语音识别" scheme="https://www.alexation.cn/tags/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
    
    <category term="pyAI-K210" scheme="https://www.alexation.cn/tags/pyAI-K210/"/>
    
    <category term="物联网" scheme="https://www.alexation.cn/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>2022湖北省大学生电子设计竞赛C题（TI杯）</title>
    <link href="https://www.alexation.cn/contest/ele2/"/>
    <id>https://www.alexation.cn/contest/ele2/</id>
    <published>2022-08-04T00:05:30.000Z</published>
    <updated>2022-08-04T01:43:14.659Z</updated>
    
    <content type="html"><![CDATA[<p><font style="font-weight:700;color:#B399FF"><em>关于作者：本科大二在读，电气专业。基础不好，不喜勿喷，感谢访问本网站，如果能给你提供新思路就是我最大的荣幸！</em></font></p><p><a href="https://ctgu.site:8003/index.php/s/B29AgRaGpdjTcEX" style="font-weight:700;color:#B399FF"><em>点击此处获取C题Word题目以及赛道标准</em></a></p><p>说实话这次算准备的不算很认真，赛前也没有针对相关模块及时进行补充学习。不过、从赛前的材料准备清单来看，基本和去年的题目很类似了。吸取去年的教训，这次准备了一些封装十分完善的MCU（有手就会那种🤫。不过因为这次是省赛，故主办方对芯片进行了限制——采用TI的MCU。（啊啊啊啊真的头疼<span class="emoji" alias="persevere" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f623.png?v8">😣</span></p><p>首先我仅代表我的组员和我感谢比赛过程中帮助过我们的同学、指导老师、以及论坛上的网友们</p><h2 style="text-align:center;font-weight:700;color:#B399FF">关于题目</h2><p>小车跟随行驶系统，设计一套小车跟随行驶系统，采用TI的MCU，由一辆领头小车和一辆跟随小车组成，要求小车具有循迹功能，且速度在0.3 ~ 1m/s可调，能在指定路径上完成行驶操作，行驶场地的路径如图1 所示。其中，路径上的A点为领头小车每次行驶的起始点和终点。当小车完成一次行驶到达终点，领头小车和跟随小车要发出声音提示。领头小车和跟随小车既可以沿着ABFDE圆角矩形（ 简称为<strong>内圈</strong> ）路径行驶，也可以沿着ABCDE的圆角矩形（ 简称为<strong>外圈</strong> ）路径行驶。</p><p><img src="https://s2.loli.net/2022/08/04/Kj3bODSVpUJxLMP.png" alt="图1"></p><p>其实今年的题目就是去年和前年控制题目的结合版，识别路口-&gt;判断转向-&gt;蓝牙通信-&gt;循迹-&gt;附加功能。这种类型的题目方案很多，因为是黑线，可以红外传感，也可以摄像头，小车跟随可以光电传感，也可以超声波测距，甚至直接写在蓝牙里面也可以。TI MCU我们不是很熟，故尽量将算法写在摄像头了。</p><h2 style="text-align:center;font-weight:700;color:#B399FF">循迹算法</h2><ol><li><p>基本的巡线：采用星瞳科技的官方例程</p></li><li><p>起点路线的判断：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Basic_speeds -&gt; 0.3m&#x2F;s -&gt; 0.5m&#x2F;s -&gt; 0.6m&#x2F;s -&gt; 0.7m&#x2F;s -&gt; 0.9m&#x2F;s -&gt; 1.0m&#x2F;sself.basic_speed_list &#x3D; [25, 40, 48, 56, 64, 70]# Question Speed and Route listsself.ques_speed_list &#x3D; [25, 40, 32, 70]self.ques_route_list &#x3D; [[2], [2,2], [2,1,2], [2]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这次将所有的配置参数提取到setting.py中构造Setting类来提高封装度，也便于修改参数，ques_route_list即是小车所要行驶的路线通过遍历这个二维列表即可以知道小车的路线，那么，关键就在于转弯路口的判断</p></li><li><p>转弯路口的判断：</p><p>特征点匹配：虽然和题目要求及其相似，但是我们也还没有尝试过，故暂不做考虑。</p><p>模板匹配：拍模板，识别出来会有反馈，因为采用模板匹配这个功能需要sensor采用灰度测试，而基本的线路拟合又是RGB565，如果二者交叉测试的话，又担心MCU处理不过来，故也没有考虑模板匹配</p><p><img src="https://s2.loli.net/2022/08/04/fyCvDsmzwSl1EuR.png" alt=""></p><p><img src="https://s2.loli.net/2022/08/04/fy2Jg1SAZPCatGi.png" alt="当时拍的两张照片"></p><p>直线检测：遇到0°线段宽度大于设定值时则判断起停线，或者90°线段有检测到时判断起停线。我们组采用的是这种方法，因为看起来逻辑可行，有算法支撑，也不涉及到example的存储。但是参数整定真的好难！<span class="emoji" alias="cry" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span>我们一直调到比赛结束也没有调的很好。</p></li></ol><h2 style="text-align:center;font-weight:700;color:#B399FF">细节实现</h2><ol><li>小车路线的确定：题目中要求跟随小车的行驶<strong>完全</strong>由领头小车指挥控制，<strong>领头小车</strong>上有<strong>启动按键</strong>和<strong>设置按键</strong>，而<strong>跟随小车</strong>只有一个<strong>上电开关</strong>，不得有其他启动和操作按键。每一次行驶发车时，领头小车和跟随小车按照题目要求摆放在行驶路径的指定位置，跟随小车上电，处于等待接收领头小车指令的状态。领头小车一键启动行驶，直到整个行驶过程结束。故采用MSP430上的按键GPIO输出到OpenMV的固定端口上，再和Setting中设定的任务路线相匹配即可知道路线。</li><li>PID调节：这部分<a href="https://book.openmv.cc/project/follow-lines.html" style="font-weight:700;color:#B399FF">星瞳科技快速上手部分</a>有提供源码，这里不进行过多解释</li><li>蜂鸣器：普通GPIO即可</li><li>蓝牙：串口通信，传输的数字对应相应的任务（0-3），4代表停车信号。</li><li>转弯方式：这里其实考虑了好多方法，包括定点sleep、开环转弯、设定ROI区域、调节PID…实际采用的是重新设定ROI区域，但效果不是很理想，包括后面并道的时候会有误差，而且实际的PID参数的整定还和车的长度、宽度等因素有关，不恰当的PID、ROI等参数会导致车轮打滑。</li></ol><h2 style="text-align:center;font-weight:700;color:#B399FF">反思总结</h2><ol><li>这次硬件和赛道很快到位，主要卡在了MCU的选择以及蓝牙通信上</li><li>PID参数整定出现严重问题！机械地进行调参，没有结合实际车的长宽等硬件信息，过于理想化了。</li><li>启停线识别方案选择错误，最后也没有时间修改了，是我的错</li><li>软件封装有些晚了，应尽早确定方案后进行封装，将参数接口暴露。</li></ol><p><font style="font-weight:700;color:#B399FF">不管成功或失败，曾经经历过，这四天拼搏的日子是我永远的记忆</font></p>]]></content>
    
    
    <summary type="html">这次是真的什么也没准备。。。不过好在去年积累了相关经验、一些模块也变得好上手了些</summary>
    
    
    
    <category term="竞赛" scheme="https://www.alexation.cn/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="Python" scheme="https://www.alexation.cn/tags/Python/"/>
    
    <category term="可恶的电赛" scheme="https://www.alexation.cn/tags/%E5%8F%AF%E6%81%B6%E7%9A%84%E7%94%B5%E8%B5%9B/"/>
    
    <category term="OpenMV" scheme="https://www.alexation.cn/tags/OpenMV/"/>
    
    <category term="MSP430" scheme="https://www.alexation.cn/tags/MSP430/"/>
    
  </entry>
  
  <entry>
    <title>数据分析Demo</title>
    <link href="https://www.alexation.cn/python-data/some-demo/"/>
    <id>https://www.alexation.cn/python-data/some-demo/</id>
    <published>2022-07-09T02:20:05.000Z</published>
    <updated>2022-08-03T22:55:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>由于平时经常有利用Excel、txt等大量数据绘图等需求、当想要去扒代码时又不记得怎么写了…还得翻以前做的CV过来、故这里做一份Python常见的库函数开发，方便自己查找，也算是一份学习记录总结啦。</p><h2 id="Python常见库开发">Python常见库开发</h2><h3 id="Matplotlib">Matplotlib</h3><p><strong>可视化视图都有哪些？</strong></p><p>按照数据之间的关系，我们可以把可视化视图划分为4类，它们分别是比较、联系、构成和分布。我来简单介绍下这四种关系的特点：</p><ol><li>比较：比较数据间各类别的关系，或者是它们随着时间的变化趋势，比如折线图；</li><li>联系：查看两个或两个以上变量之间的关系，比如散点图；</li><li>构成：每个部分占整体的百分比，或者是随着时间的百分比变化，比如饼图；</li><li>分布：关注单个变量，或者多个变量的分布情况，比如直方图。</li></ol><p>同样，按照变量的个数，我们可以把可视化视图划分为单变量分析和多变量分析。</p><p>单变量分析指的是一次只关注一个变量。比如我们只关注“身高”这个变量，来看身高的取值分布，而暂时忽略其他变量。</p><p>多变量分析可以让你在一张图上可以查看两个以上变量的关系。比如“身高”和“年龄”，你可以理解是同一个人的两个参数，这样在同一张图中可以看到每个人的“身高”和“年龄”的取值，从而分析出来这两个变量之间是否存在某种联系。</p><p>可视化的视图可以说是分门别类，多种多样，今天我主要介绍常用的10种视图，这些视图包括了散点图、折线图、直方图、条形图、箱线图、饼图、热力图、蜘蛛图、二元变量分布和成对关系。</p><p><img src="https://s2.loli.net/2022/07/09/QhFDqmrjysfkAgi.png" alt=""></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import matplotlib.pyplot as plt# 0.准备数据x &#x3D; [1, 2, 3, 4, 5, 6, 7]y_shanghai &#x3D; [17, 17, 18, 15, 11, 11, 13]# 1.创建画布# figsize:指定图的长宽# dpi:图像的清晰度# 返回fig对象plt.figure(figsize&#x3D;(20, 8), dpi&#x3D;100)# 2.绘制图像plt.plot(x, y_shanghai)# 3.图像显示plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加自定义x,y刻度</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 增加以下两行代码# 2.1 添加x,y轴刻度# 设置x,y轴刻度x_ticks_label &#x3D; [&quot;11点&#123;&#125;分&quot;.format(i) for i in x]y_ticks &#x3D; range(40)# 修改x,y轴坐标刻度显示# plt.xticks(x_ticks_label[::5]) # 坐标刻度不可以直接通过字符串进行修改plt.xticks(x[::5], x_ticks_label[::5])plt.yticks(y_ticks[::5])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加网格显示</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 2.2 添加网格显示plt.grid(True, linestyle&#x3D;&quot;--&quot;, alpha&#x3D;1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>添加x轴、y轴描述信息及标题</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 2.3 添加描述信息plt.xlabel(&quot;时间&quot;)plt.ylabel(&quot;温度&quot;)plt.title(&quot;中午11点-12点某城市温度变化图&quot;, fontsize&#x3D;20)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>绘制多个图像</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 增加北京的温度数据y_beijing &#x3D; [random.uniform(1, 3) for i in x]# 2.绘制图像plt.plot(x, y_shanghai, label&#x3D;&quot;上海&quot;)plt.plot(x, y_beijing, color&#x3D;&quot;r&quot;, linestyle&#x3D;&quot;--&quot;, label&#x3D;&quot;北京&quot;)  # 新增绘制北京的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示图例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 绘制折线图plt.plot(x, y_shanghai, label&#x3D;&quot;上海&quot;)# 使用多次plot可以画多个折线plt.plot(x, y_beijing, color&#x3D;&#39;r&#39;, linestyle&#x3D;&#39;--&#39;, label&#x3D;&quot;北京&quot;)# 显示图例plt.legend(loc&#x3D;&quot;best&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多个坐标系显示</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 0.准备数据x &#x3D; range(60)y_shanghai &#x3D; [random.uniform(15, 18) for i in x]y_beijing &#x3D; [random.uniform(1, 5) for i in x]# 1.创建画布# plt.figure(figsize&#x3D;(20, 8), dpi&#x3D;100)fig, axes &#x3D; plt.subplots(nrows&#x3D;1, ncols&#x3D;2, figsize&#x3D;(20, 8), dpi&#x3D;100)# 2.绘制图像# plt.plot(x, y_shanghai, label&#x3D;&quot;上海&quot;)# plt.plot(x, y_beijing, color&#x3D;&quot;r&quot;, linestyle&#x3D;&quot;--&quot;, label&#x3D;&quot;北京&quot;)axes[0].plot(x, y_shanghai, label&#x3D;&quot;上海&quot;)axes[1].plot(x, y_beijing, color&#x3D;&quot;r&quot;, linestyle&#x3D;&quot;--&quot;, label&#x3D;&quot;北京&quot;)# 2.1 添加x,y轴刻度# 构造x,y轴刻度标签x_ticks_label &#x3D; [&quot;11点&#123;&#125;分&quot;.format(i) for i in x]y_ticks &#x3D; range(40)# 刻度显示# plt.xticks(x[::5], x_ticks_label[::5])# plt.yticks(y_ticks[::5])axes[0].set_xticks(x[::5])axes[0].set_yticks(y_ticks[::5])axes[0].set_xticklabels(x_ticks_label[::5])axes[1].set_xticks(x[::5])axes[1].set_yticks(y_ticks[::5])axes[1].set_xticklabels(x_ticks_label[::5])# 2.2 添加网格显示# plt.grid(True, linestyle&#x3D;&quot;--&quot;, alpha&#x3D;0.5)axes[0].grid(True, linestyle&#x3D;&quot;--&quot;, alpha&#x3D;0.5)axes[1].grid(True, linestyle&#x3D;&quot;--&quot;, alpha&#x3D;0.5)# 2.3 添加描述信息# plt.xlabel(&quot;时间&quot;)# plt.ylabel(&quot;温度&quot;)# plt.title(&quot;中午11点--12点某城市温度变化图&quot;, fontsize&#x3D;20)axes[0].set_xlabel(&quot;时间&quot;)axes[0].set_ylabel(&quot;温度&quot;)axes[0].set_title(&quot;中午11点--12点某城市温度变化图&quot;, fontsize&#x3D;20)axes[1].set_xlabel(&quot;时间&quot;)axes[1].set_ylabel(&quot;温度&quot;)axes[1].set_title(&quot;中午11点--12点某城市温度变化图&quot;, fontsize&#x3D;20)# # 2.4 图像保存plt.savefig(&quot;.&#x2F;test.png&quot;)# # 2.5 添加图例# plt.legend(loc&#x3D;0)axes[0].legend(loc&#x3D;0)axes[1].legend(loc&#x3D;0)# 3.图像显示plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="小结">小结</h4><ul><li>添加x,y轴刻度【知道】<ul><li>plt.xticks()</li><li>plt.yticks()</li><li><strong>注意:在传递进去的第一个参数必须是数字,不能是字符串,如果是字符串吗,需要进行替换操作</strong></li></ul></li><li>添加网格显示【知道】<ul><li>plt.grid(linestyle=“–”, alpha=0.5)</li></ul></li><li>添加描述信息【知道】<ul><li>plt.xlabel()</li><li>plt.ylabel()</li><li>plt.title()</li></ul></li><li>图像保存【知道】<ul><li>plt.savefig(“路径”)</li></ul></li><li>多次plot【了解】<ul><li>直接进行添加就OK</li></ul></li><li>显示图例【知道】<ul><li>plt.legend(loc=“best”)</li><li><strong>注意:一定要在plt.plot()里面设置一个label,如果不设置,没法显示</strong></li></ul></li><li>多个坐标系显示【了解】<ul><li>plt.subplots(nrows=, ncols=)</li></ul></li><li>折线图的应用【知道】<ul><li>1.应用于观察数据的变化</li><li>2.可是画出一些数学函数图像</li></ul></li></ul><h4 id="附录：中文显示问题解决">附录：中文显示问题解决</h4><p><strong>解决方案二：</strong></p><p>在Python脚本中动态设置matplotlibrc,这样也可以避免由于更改配置文件而造成的麻烦，具体代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import matplotlib.pyplot as plt# 设置显示中文字体plt.rcParams[&#39;font.sans-serif&#39;] &#x3D; [&#39;SimHei&#39;] # 指定默认字体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有时候，字体更改后，会导致坐标轴中的部分字符无法正常显示，此时需要更改axes.unicode_minus参数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 设置正常显示符号plt.rcParams[&#39;axes.unicode_minus&#39;] &#x3D; False <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Numpy">Numpy</h3><p><code>NumPy</code>是一个功能强大的<code>Python</code>库，主要用于对多维数组执行计算。<code>NumPy</code>这个词来源于两个单词-- <code>Numerical</code>和<code>Python</code>。<code>NumPy</code>提供了大量的库函数和操作，可以帮助程序员轻松地进行数值计算。在数据分析和机器学习领域被广泛使用。他有以下几个特点：</p><ol><li>Numpy内置了并行运算功能，当系统有多个核心时，做某种计算时，numpy会自动做并行计算。</li><li>Numpy底层使用C语言编写，内部解除了GIL（全局解释器锁），其对数组的操作速度不受Python解释器的限制，效率远高于纯Python代码。</li><li>实用的线性代数、傅里叶变换和随机数生成函数。</li></ol><p>总而言之，Numpy一个非常高效的用于处理数值型运算的包。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于平时经常有利用Excel、txt等大量数据绘图等需求、当想要去扒代码时又不记得怎么写了…还得翻以前做的CV过来、故这里做一份Python常见的库函数开发，方便自己查找，也算是一份学习记录总结啦。&lt;/p&gt;
&lt;h2 id=&quot;Python常见库开发&quot;&gt;Python常见库开发&lt;</summary>
      
    
    
    
    <category term="Python" scheme="https://www.alexation.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.alexation.cn/tags/Python/"/>
    
    <category term="Matplotlib" scheme="https://www.alexation.cn/tags/Matplotlib/"/>
    
    <category term="numpy" scheme="https://www.alexation.cn/tags/numpy/"/>
    
    <category term="pandas" scheme="https://www.alexation.cn/tags/pandas/"/>
    
    <category term="Pyecharts" scheme="https://www.alexation.cn/tags/Pyecharts/"/>
    
  </entry>
  
  <entry>
    <title>数据分析的基础知识以及环境搭建（附Jupyter快捷键）</title>
    <link href="https://www.alexation.cn/python-data/data-base/"/>
    <id>https://www.alexation.cn/python-data/data-base/</id>
    <published>2022-06-15T06:13:05.000Z</published>
    <updated>2022-07-09T02:56:20.756Z</updated>
    
    <content type="html"><![CDATA[<h1>01 数据分析基础</h1><h2 id="一、数据分析介绍">一、数据分析介绍</h2><p>当我们谈论数据分析的时候，都在讲些什么呢？</p><p>这里我可以把数据分析分成三个重要的组成部分。</p><ol><li><strong>数据采集</strong>。它是数据分析的原材料，也是最“<strong>接地气</strong>”的部分，因为任何分析都要有数据源。</li><li><strong>数据分析</strong>。就是针对现有的数据，进行专业的技术进行分析，并得到一份分析报告。</li><li><strong>数据可视化</strong>。它可以说是数据领域中万金油的技能，可以让我们直观地了解到数据分析的结果。</li><li><strong>数据挖掘</strong>。它最核心的部分，也是整个商业价值所在。之所以要进行数据分析，就是要找到其中的规律，来指导我们的业务，或者是给领导做出决策提供参考信息。因此<strong>数据挖掘的核心是挖掘数据的商业价值，也就是我们所谈的商业智能BI</strong>。</li></ol><p><img src="https://s2.loli.net/2022/07/09/dZxJCaSLPKQs9U7.png" alt=""></p><h3 id="1、1-生活中的数据分析">1、1 生活中的数据分析</h3><h4 id="1、1、1-无处不在的数据">1、1、1 无处不在的数据</h4><blockquote><p>生活中存在各式各样的数据，那么基于这些数据，我们又能做哪些分析呢？</p></blockquote><p>最近几年大数据这个词是火的不行，确实随着社会科技水平的提高，我们使用电子设备的时间越来越长，现在数据的增长量真的非常非常快，这些数据来自各个领域，比如：</p><ul><li>社交：微信，微博，知乎，豆瓣什么的</li><li>交通：出租车，公交车等类的数据，比如：滴滴出行</li><li>金融：股票历史交易信息，公司财报，新闻媒体的态度等等</li><li>医疗：在数据收集和存储上还有很长的路要走</li></ul><p><strong>典型的数据分析应用</strong>：</p><ul><li>竞选预测：特朗普和拜登</li><li>拥堵预测：交通出行，地图导航</li><li>信誉评估：信用额度贷款等</li><li>辅助诊断：医疗影像等方面，比如 ：CT图像中的肿瘤</li></ul><h4 id="1、1、2-数据分析的作用">1、1、2 数据分析的作用</h4><p><strong>数据分析是指用适当的统计分析方法对收集来的大量数据进行分析，提取有用信息和形成结论而对数据加以详细研究和概括总结的过程。</strong></p><p>数据分析的目的有多种，概括起来有三种：</p><ul><li>现状分析:告诉你过去发生了什么。     探索型数据分析</li><li>原因分析:告诉你某一现状为什么发生。      验证型数据分析</li><li>预测分析:预测未来会发生什么。                 预测型数据分析</li></ul><h4 id="1、1、3-为什么需要数据分析能力？">1、1、3 为什么需要数据分析能力？</h4><p>举例：</p><ol><li>通过数据分析，我们可以更好地了解用户画像，为企业做留存率、流失率等指标分析，进而精细化产品运营。</li><li>面对生活中遇到的种种麻烦，数据分析也可以提供解决方案，比如信用卡反欺诈，自动屏蔽垃圾邮件等。</li><li>如果你关注比特币，数据分析可以帮助你预测比特币的走势。</li></ol><p><strong>案例分析</strong></p><p>故事内容这个故事发生于20世纪90年代的美国超市中，超市管理人员分析销售数据时发现了一个令人难于理解的现象：在某些特定的情况下，“啤酒”与“尿布”两件看上去毫无关系的商品会经常出现在同一个购物篮中，这种独特的销售现象引起了管理人员的注意，经过后续调查发现，这种现象出现在年轻的父亲身上。</p><p>故事起因在美国有婴儿的家庭中，一般是母亲在家中照看婴儿，年轻的父亲前去超市购买尿布。父亲在购买尿布的同时，往往会顺便为自己购买啤酒，这样就会出现啤酒与尿布这两件看上去不相干的商品经常会出现在同一个购物篮的现象。</p><p>如果这个年轻的父亲在卖场只能买到两件商品之一，则他很有可能会放弃购物而到另一家商店，直到可以一次同时买到啤酒与尿布为止。</p><p>超市发现了这一独特的现象，开始在卖场尝试将啤酒与尿布摆放在相同的区域，让年轻的父亲可以同时找到这两件商品，并很快地完成购物。</p><p>故事小结这个故事是因为有数据分析的结果支持才会获得成功并得到广泛传播，通过分析购物篮中的商品集合数据，找出商品之间的关联关系，发现客户的购买行为，从而获得更多的商品销售收入</p><blockquote><p>经典数据挖掘案例：<a href="https://www.sohu.com/a/243626833_99923499">https://www.sohu.com/a/243626833_99923499</a></p></blockquote><h2 id="二、环境搭建">二、环境搭建</h2><h3 id="2、1-Anaconda：">2、1 Anaconda：</h3><p><code>Anaconda（水蟒）</code>是一个捆绑了<code>Python</code>、<code>conda</code>、其他相关依赖包的一个软件。包含了180多个科学计算包及其依赖。<code>Anaconda3</code>是集成了<code>Python3</code>的环境，<code>Anaconda2</code>是集成了<code>Python2</code>的环境。<code>Anaconda</code>默认集成的包，是属于内置的<code>Python</code>的包。并且支持绝大部分操作系统（比如：Windows、Mac、Linux等）。下载地址如下：<code>https://www.anaconda.com/distribution/</code>（如果官网下载太慢，可以在清华大学开源软件站中下载：<code>https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</code>）。根据自己的操作系统，下载相应的版本，因为<code>Anaconda</code>内置了许多的包，所以安装过程需要耗费相当长的时间，大家在安装的时候需要耐心等待。在安装完成后，会有以下几个模块：<code>Anaconda prompt</code>、<code>Anaconda Navigator</code>、<code>Spyder</code>、<code>jupyter notebook</code>，以下分别做一些介绍。</p><h4 id="2、1、1-Anaconda-prompt：">2、1、1 Anaconda prompt：</h4><p><code>Anaconda prompt</code>是专门用来操作<code>anaconda</code>的终端。如果你安装完<code>Anaconda</code>后没有在环境变量的<code>PATH</code>中添加相关的环境变量，那么以后你想在终端使用<code>anaconda</code>相关的命令，则必须要在<code>Anaconda prompt</code>中完成。</p><h4 id="2、1、2-Anaconda-Navigator：">2、1、2 Anaconda Navigator：</h4><p>这个相当于是一个导航面板，上面组织了<code>Anaconda</code>相关的软件。</p><h4 id="2、1、3-Spyder：">2、1、3 Spyder：</h4><p>一个专门开发<code>Python</code>的软件，熟悉<code>MATLAB</code>的同学会比较有亲切感，但在后期的学习过程中，我们将不会使用这个工具写代码，因为还有更好的可替代的工具。</p><h3 id="2、2-Jupyter-介绍">2、2 Jupyter 介绍</h3><p>Jupyter项目是一个非盈利的开源项目，源于2014年的ipython项目，因为它逐渐发展为支持跨所有编程语言的交互式数据科学和科学计算</p><ul><li>Jupyter Notebook，原名IPython Notbook，是IPython的加强网页版，一个开源Web应用程序</li><li>名字源自Julia、Python 和 R（数据科学的三种开源语言）</li><li>是一款程序员和科学工作者的<strong>编程/文档/笔记/展示</strong>软件</li><li><strong>.ipynb</strong>文件格式是用于计算型叙述的<strong>JSON文档格式</strong>的正式规范</li></ul><h4 id="2、2、1-为什么使用-Jupyter-Notebook">2、2、1 为什么使用 Jupyter Notebook ?</h4><ul><li>传统软件开发： 工程／目标明确<ul><li>需求分析，设计架构，开发模块，测试</li></ul></li><li>数据挖掘：艺术／目标不明确<ul><li>目的是具体的洞察目标，而不是机械的完成任务</li><li>通过执行代码来理解问题</li><li>迭代式地改进代码来改进解决方法</li></ul></li></ul><p>实时运行的代码、叙事性的文本和可视化被整合在一起，方便使用代码和数据来讲述故事</p><p>一个Python编辑环境，可以实时的查看代码的运行效果。</p><h4 id="2、2、2-对比-Jupyter-Notebook-和-Pycharm">2、2、2 对比 Jupyter Notebook 和 Pycharm</h4><p>Jupyter Notebook 相比 Pycharm 在画图和数据展示方面更有优势。</p><h3 id="2、3-Jupyter-Notebook-的使用">2、3 Jupyter Notebook 的使用</h3><h4 id="2、3、1-jupyter-安装与适配">2、3、1 jupyter 安装与适配</h4><ul><li><p>首先在终端下安装 jupyter，Anaconda环境下默认自带会安装</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pip install jupyter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>安装jupyter拓展库</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pip install autopep8  # 安装pep8代码规范的模块pip install jupyter_contrib_nbextensions  # 安装 jupyter 拓展包pip install yapf  # 安装拓展包依赖的第三方功能模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>拓展包安装后需要执行命令适配</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">&quot;&quot;&quot;拓展包适配&quot;&quot;&quot;jupyter contrib nbextension install --userjupyter nbextension enable code_prettify&#x2F;code_prettify<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>环境搭建好后，在命令行下输入 <code>jupyter notebook</code> 命令，会自动弹出浏览器窗口打开 Jupyter Notebook</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd"># 输入命令jupyter notebook<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>本地notebook的默认URL为：<a href="http://localhost:8888">http://localhost:8888</a></p><blockquote><p>想让notebook打开指定目录，只要进入此目录后执行命令即可</p></blockquote></li><li><p>打开<code>jupyter notebook</code>以后，在<code>Nbextensions</code>选项下勾选配置选项，如下图所示：</p></li><li><p>添加拓展配置以后的效果</p></li><li><p><code>Jupyter notebook</code>汉化，更改为中文界面</p><ul><li><p>首先桌面-此电脑-右击 属性，选择<strong>高级系统设置</strong></p></li><li><p>弹出的选项卡中，选择 高级–环境变量</p></li><li><p>选择上面的用户变量，是用户变量，点击新建，新建用户变量</p><pre class="line-numbers language-none"><code class="language-none">变量名：LANG     变量值：zh_CN.UTF8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><pre class="line-numbers language-none"><code class="language-none">  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><blockquote><p>重要：配置好后需要关闭cmd终端，重新启动<code>jupyter</code>才会生效。</p></blockquote></li></ul><h4 id="2、3、2-创建文件">2、3、2 创建文件</h4><ul><li><p>新建notebook文档</p></li><li><p>内容界面操作</p></li></ul><p>**标题栏：**点击标题（如Untitled）修改文档名</p><h4 id="2、3、3-cell-单元格操作">2、3、3 cell 单元格操作</h4><ul><li>什么是cell？<ul><li><strong>cell</strong>：一对In Out会话被视作一个代码单元，称为cell</li><li>cell行号前的 * ，表示代码正在运行</li></ul></li></ul><p>Jupyter支持两种模式：</p><ul><li>编辑模式（Enter）<ul><li>命令模式下<code>回车Enter</code>或<code>鼠标双击</code>cell进入编辑模式</li><li>可以<strong>操作cell内文本</strong>或代码，剪切／复制／粘贴移动等操作</li></ul></li><li>命令模式（Esc）<ul><li>按<code>Esc</code>退出编辑，进入命令模式</li><li>可以<strong>操作cell单元本身</strong>进行剪切／复制／粘贴／移动等操作</li></ul></li></ul><h5 id="快捷键操作">快捷键操作</h5><ul><li><p>两种模式通用快捷键</p><ul><li><strong><code>Shift+Enter</code>，执行本单元代码，并跳转到下一单元</strong></li><li><strong><code>Ctrl+Enter</code>，执行本单元代码，留在本单元</strong></li></ul></li><li><p><strong>命令模式</strong>：按ESC进入</p><ul><li>Y ：在命令模式下转入代码状态</li><li>M ：在命令模式下切换到 Markdown</li><li>R ：普通文本，运行不会输出结果</li><li>L ：为当前cell加上行号</li><li>A：在该单元格的上方插入新单元格</li><li>B：在该单元格的下方插入新单元格</li><li>X：剪切选中的单元</li><li>C：复制选中的单元</li><li>V：粘贴到下方单元</li><li>DD：删除选中的单元（敲两个D）</li></ul></li><li><p>其他(了解)</p><ul><li><code>双击D</code>：删除当前cell</li><li><code>Z</code>，回退</li><li>快速跳转到首个cell，<code>Crtl+Home</code></li><li>快速跳转到最后一个cell，<code>Crtl+End</code> --&gt;</li></ul></li><li><p><strong>编辑模式</strong>：按Enter进入</p><ul><li>补全代码：变量、方法后跟<code>Tab键</code></li><li>为一行或多行代码添加/取消注释：<code>Ctrl+/</code>（Mac:CMD+/）</li></ul></li><li><p>其他(了解)：</p><ul><li>多光标操作：<code>Ctrl键点击鼠标</code>（Mac:CMD+点击鼠标）</li><li>回退：<code>Ctrl+Z</code>（Mac:CMD+Z）</li><li>重做：<code>Ctrl+Y</code>（Mac:CMD+Y)</li></ul></li></ul><h5 id="markdown演示">markdown演示</h5><p>掌握标题和缩进即可</p><h5 id="其他操作">其他操作</h5><blockquote><p>函数名 + ? 查看源码</p></blockquote><blockquote><p>Tab 自动补全：如果敲代码没有自动补全，可以用<strong>Tab</strong>查看代码提示</p></blockquote><h2 id="三、小结及注意事项">三、小结及注意事项</h2><ul><li>是什么<ul><li>是一个 ipython 的 web 加强版</li></ul></li><li>为什么要使用jupyter<ul><li>用于数据探索过程</li></ul></li><li>怎么用<ul><li>1.通过 jupyter notebook 就可以使用</li><li>2.保存文件是.ipynb</li><li>3.每个内容,都对应的是一个cell</li></ul></li><li>快捷键<ul><li><p>Shift+Enter，执行本单元代码，并跳转到下一单元</p></li><li><p>Ctrl+Enter，执行本单元代码，留在本单元</p></li></ul></li></ul><p><strong>注意事项</strong></p><p><code>jupyter notebook</code>每一个<code>cell</code>运行完后都会把这个<code>cell</code>中的变量保存到内存中，如果在一个<code>cell</code>中修改了之前的变量，再此运行这个<code>cell</code>的时候可能会导致一些问题产生。比如以下代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 第一个cell中的代码a &#x3D; 10b &#x3D; 20# 第二个cell中的代码c &#x3D; a&#x2F;bb &#x3D; 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为第二个<code>cell</code>修改了<code>b</code>变量，此时在整个环境中<code>b</code>都是等于0的，所以以后再运行这个<code>cell</code>的时候，<code>a/b</code>这个就会出问题了。这时候可以使用<code>Kernel-&gt;Restart&amp;Run All</code>来重新运行整个项目。</p><h2 id="附录：Jupyter-常用快捷键">附录：Jupyter 常用快捷键</h2><h3 id="命令模式（按Esc键）：">命令模式（按Esc键）：</h3><ol><li>Enter：转入编辑模式</li><li>Shift-Enter：运行本单元，选中下个单元</li><li>Ctrl-Enter：运行本单元</li><li>Alt-Enter：运行本单元，在其下插入新单元</li><li>Y：单元转入代码状态</li><li>M：单元转入markdown状态</li><li>R：单元转入raw状态</li><li>1：设定 1 级标题</li><li>2：设定 2 级标题</li><li>3：设定 3 级标题</li><li>4：设定 4 级标题</li><li>5：设定 5 级标题</li><li>6：设定 6 级标题</li><li>Up：选中上方单元</li><li>K：选中上方单元</li><li>Down：选中下方单元</li><li>J：选中下方单元</li><li>Shift-K：扩大选中上方单元</li><li>Shift-J：扩大选中下方单元</li><li>A：在上方插入新单元</li><li>B：在下方插入新单元</li><li>X：剪切选中的单元</li><li>C：复制选中的单元</li><li>Shift-V：粘贴到上方单元</li><li>V：粘贴到下方单元</li><li>Z：恢复删除的最后一个单元</li><li>D,D：删除选中的单元</li><li>Shift-M：合并选中的单元</li><li>Ctrl-S：文件存盘</li><li>S：文件存盘</li><li>L：转换行号</li><li>O：转换输出</li><li>Shift-O：转换输出滚动</li><li>Esc：关闭页面</li><li>Q：关闭页面</li><li>H：显示快捷键帮助</li><li>I,I：中断Notebook内核</li><li>0,0：重启Notebook内核</li><li>Shift：忽略</li><li>Shift-Space：向上滚动</li><li>Space：向下滚动</li></ol><h3 id="编辑模式：">编辑模式：</h3><ol><li>Tab : 代码补全或缩进</li><li>Shift-Tab : 提示</li><li>Ctrl-] : 缩进</li><li>Ctrl-[ : 解除缩进</li><li>Ctrl-A : 全选</li><li>Ctrl-Z : 复原</li><li>Ctrl-Shift-Z : 再做</li><li>Ctrl-Y : 再做</li><li>Ctrl-Home : 跳到单元开头</li><li>Ctrl-Up : 跳到单元开头</li><li>Ctrl-End : 跳到单元末尾</li><li>Ctrl-Down : 跳到单元末尾</li><li>Ctrl-Left : 跳到左边一个字首</li><li>Ctrl-Right : 跳到右边一个字首</li><li>Ctrl-Backspace : 删除前面一个字</li><li>Ctrl-Delete : 删除后面一个字</li><li>Esc : 进入命令模式</li><li>Ctrl-M : 进入命令模式</li><li>Shift-Enter : 运行本单元，选中下一单元</li><li>Ctrl-Enter : 运行本单元</li><li>Alt-Enter : 运行本单元，在下面插入一单元</li><li>Ctrl-Shift-- : 分割单元</li><li>Ctrl-Shift-Subtract : 分割单元</li><li>Ctrl-S : 文件存盘</li><li>Shift : 忽略</li><li>Up : 光标上移或转入上一单元</li><li>Down :光标下移或转入下一单元</li></ol><h2 id="附录：conda基本使用">附录：conda基本使用</h2><p><code>conda</code>伴随着<code>Anaconda</code>安装而自动安装的。<code>conda</code>可以跟<code>virtualenv</code>一样管理不同的环境，也可以跟<code>pip</code>一样管理某个环境下的包。以下来看看两个功能的用法。</p><h3 id="环境管理：">环境管理：</h3><p><code>conda</code>能跟<code>virtualenv</code>一样管理不同的<code>Python</code>环境，不同的环境之间是互相隔离，互不影响的。为什么需要创建不同的环境呢？原因是有时候项目比较多，但是项目依赖的包不一样，比如<code>A</code>项目用的是<code>Python2</code>开发的，而<code>B</code>项目用的是<code>Python3</code>开发的，那么我们在同一台电脑上就需要两套不同的环境来支撑他们运行了。创建环境的基本命令如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># conda create --name [环境名称] 比如以下：conda create --name da-env<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样将创建一个叫做<code>da-env</code>的环境，这个环境的<code>python</code>解释器根据<code>anaconda</code>来，如果<code>anaconda</code>为<code>3.7</code>，那么将默认使用<code>3.7</code>的环境，如果<code>anaconda</code>内置的是<code>2.7</code>，那么将默认使用<code>2.7</code>的环境。然后你就可以使用<code>conda install numpy</code>的方式来安装包了，并且这样安装进来的包，只会安装在当前环境中。有的同学可能有想问，如果想要装一个<code>Python2.7</code>的环境，<code>anaconda</code>中没有内置<code>Python2.7</code>，那么该怎么实现呢？。实际上，我们只需要在安装的时候指定<code>python</code>的版本，如果这个版本现在不存在，那么<code>anaconda</code>会自动的给我们下载。所以安装<code>Python2.7</code>的环境，使用以下代码即可实现：</p><pre class="line-numbers language-none"><code class="language-none">conda create --name xxx python&#x3D;2.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下再列出<code>conda</code>管理环境的其他命令：</p><ol><li><p>创建的时候指定需要安装的包：</p><pre class="line-numbers language-none"><code class="language-none">conda create --name xxx numpy pandas<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建的时候既需要指定包，也需要指定python环境：</p><pre class="line-numbers language-none"><code class="language-none">conda create --name xxx python&#x3D;3.6 numpy pandas<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>进入到某个环境</p><pre class="line-numbers language-none"><code class="language-none">windows: activate xxxmac&#x2F;linux: source activate xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>退出环境：</p><pre class="line-numbers language-none"><code class="language-none">deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>列出当前所有的环境：</p><pre class="line-numbers language-none"><code class="language-none">conda env list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>移除某个环境：</p><pre class="line-numbers language-none"><code class="language-none">conda remove --name xxx --all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>环境下的包导出和导入：</p><ul><li>导出：<code>conda env export &gt; environment.yml</code>。</li><li>导入：<code>conda env create --name xxx -f environment.yml</code>。</li></ul></li></ol><h4 id="包管理：">包管理：</h4><p><code>conda</code>也可以用来管理包。比如我们创建完一个新的环境后，想要在这个环境中安装包（比如numpy），那么可以通过以下代码来实现：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">activate xxxconda install numpy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以下再介绍一些包管理常用的命令：</p><ol><li><p>在不进入某个环境下直接给这个环境安装包：</p><pre class="line-numbers language-none"><code class="language-none">conda install [包名] -n [环境名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>列出该环境下所有的包：</p><pre class="line-numbers language-none"><code class="language-none">conda list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>卸载某个包：</p><pre class="line-numbers language-none"><code class="language-none">conda remove [包名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置安装包的源：</p><pre class="line-numbers language-none"><code class="language-none">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main&#x2F;conda config --set show_channel_urls yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;01 数据分析基础&lt;/h1&gt;
&lt;h2 id=&quot;一、数据分析介绍&quot;&gt;一、数据分析介绍&lt;/h2&gt;
&lt;p&gt;当我们谈论数据分析的时候，都在讲些什么呢？&lt;/p&gt;
&lt;p&gt;这里我可以把数据分析分成三个重要的组成部分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据采集&lt;/strong&gt;</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.alexation.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://www.alexation.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>MySQL语句</title>
    <link href="https://www.alexation.cn/backend/mysql/"/>
    <id>https://www.alexation.cn/backend/mysql/</id>
    <published>2022-04-28T08:22:40.000Z</published>
    <updated>2022-08-03T22:54:45.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL的数据类型">MySQL的数据类型</h3><ul><li>MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</li><li>备注: char 和varchar 一定要指定长度，float 会自动提升为double，timestamp 是时间的混合类型，理 论上可以存储 时间格式和时间戳。</li></ul><table><thead><tr><th>类型</th><th>用途</th></tr></thead><tbody><tr><td>int</td><td>整型，相当于java的int</td></tr><tr><td>bigint</td><td>整型，相当于java的long</td></tr><tr><td>float</td><td>浮点型</td></tr><tr><td>double</td><td>浮点型</td></tr><tr><td>datatime</td><td>日期类型</td></tr><tr><td>timestamp</td><td>日期类型（可储存时间戳</td></tr><tr><td>char</td><td>定长字符</td></tr><tr><td>varchar</td><td>不定长字符</td></tr><tr><td>text</td><td>大文本，用于储存比较长的字符内容</td></tr><tr><td>blob</td><td>字节数据类型，储存图片、音频等文件</td></tr></tbody></table><h3 id="建表操作">建表操作</h3><p>– 删除表<br>DROP TABLE IF EXISTS 表名;<br>– 新建表<br>create table 表名(字段名 类型 约束（主键，非空，唯一，默认值），字段名 类型 约束（主键，非空，唯一，默认值)编码，存储引擎；</p><blockquote><p>在 SQL 中，我们有如下约束：</p><ul><li>NOT NULL - 指示某列不能存储 NULL 值。</li><li>UNIQUE - 保证某列的每行必须有唯一的值。</li><li>PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助 于更容易更快速地找到表中的一个特定的记录。</li><li>FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li><li>CHECK - 保证列中的值符合指定的条件。</li><li>DEFAULT - 规定没有给列赋值时的默认值。</li></ul></blockquote><ul><li>实例</li></ul><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">DROP TABLE IF EXISTS &#96;websites&#96;;CREATE TABLE &#96;websites&#96; (id int(11) NOT NULL AUTO_INCREMENT,name char(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;站点名称&#39;,url varchar(255) NOT NULL DEFAULT &#39;&#39;,alexa int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;Alexa 排名&#39;,sal double COMMENT &#39;广告收入&#39;,country char(10) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;国家&#39;,PRIMARY KEY (id)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入、删除、更新">插入、删除、更新</h3><ul><li>插入语句</li></ul><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">INSERT INTO websites(name, url,alexa,sal,country ) VALUES (&#39;腾讯&#39;, &#39;https:&#x2F;&#x2F;www.qq.com&#39;,18, 1000,&#39;CN&#39; ) ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>删除语句</li></ul><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">delete from websites where id &#x3D; 5;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>更新语句</li></ul><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">update websites set sal &#x3D; null where id &#x3D; 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="基本select查询语句">基本select查询语句</h3><ul><li>初始化数据</li></ul><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">DROP TABLE IF EXISTS &#96;websites&#96;;CREATE TABLE &#96;websites&#96; (id int(11) NOT NULL AUTO_INCREMENT,name char(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;站点名称&#39;,url varchar(255) NOT NULL DEFAULT &#39;&#39;,alexa int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;Alexa 排名&#39;,sal double COMMENT &#39;广告收入&#39;,country char(10) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;国家&#39;,PRIMARY KEY (id)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;INSERT INTO &#96;websites&#96; VALUES(1, &#39;Google&#39;, &#39;https:&#x2F;&#x2F;www.google.cm&#x2F;&#39;, &#39;1&#39;, 2000,&#39;USA&#39;),(2, &#39;淘宝&#39;, &#39;https:&#x2F;&#x2F;www.taobao.com&#x2F;&#39;, &#39;13&#39;,2050, &#39;CN&#39;),(3, &#39;菜鸟教程&#39;, &#39;http:&#x2F;&#x2F;www.runoob.com&#x2F;&#39;, &#39;4689&#39;,0.0001, &#39;CN&#39;),(4, &#39;微博&#39;, &#39;http:&#x2F;&#x2F;weibo.com&#x2F;&#39;, &#39;20&#39;,50, &#39;CN&#39;),(5, &#39;Facebook&#39;, &#39;https:&#x2F;&#x2F;www.facebook.com&#x2F;&#39;, &#39;3&#39;, 500,&#39;USA&#39;);CREATE TABLE IF NOT EXISTS &#96;access_log&#96; (&#96;aid&#96; int(11) NOT NULL AUTO_INCREMENT,&#96;site_id&#96; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;网站id&#39;,&#96;count&#96; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;访问次数&#39;,&#96;date&#96; date NOT NULL,PRIMARY KEY (&#96;aid&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;INSERT INTO &#96;access_log&#96; (&#96;aid&#96;, &#96;site_id&#96;, &#96;count&#96;, &#96;date&#96;) VALUES(1, 1, 45, &#39;2016-05-10&#39;),(2, 3, 100, &#39;2016-05-13&#39;),(3, 1, 230, &#39;2016-05-14&#39;),(4, 2, 10, &#39;2016-05-14&#39;),(5, 5, 205, &#39;2016-05-14&#39;),(6, 4, 13, &#39;2016-05-15&#39;),(7, 3, 220, &#39;2016-05-15&#39;),(8, 5, 545, &#39;2016-05-16&#39;),(9, 3, 201, &#39;2016-05-17&#39;),(10, 88, 9999, &#39;2016-09-09&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查询语句</li></ul><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">select * from websitesselect id, name, url, alexa, sal, country from websites<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="分页查询">分页查询</h3><blockquote><p>MySQL分页很优雅</p></blockquote><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">select * from websites limit 2,3 ; -- 从第2条(下标从0开始)开始查，查3条数据select * from websites limit 3 ; -- 从第0条(下标从0开始)开始查，查3条数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="distinct关键字">distinct关键字</h3><blockquote><p>Distinct关键字用于返回唯一不同的值</p></blockquote><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">select distinct country from websites<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="where语句">where语句</h3><blockquote><p>作为条件筛选, 运算符: &gt; &lt; &gt;= &lt;= &lt;&gt; != =</p><p>is null is not null (因为在sql 语句中null 和任何东西比较都是假，包括它本身)</p><p>like in</p></blockquote><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">select * from websites where sal &gt; 500<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="逻辑条件：and、or">逻辑条件：and、or</h3><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">select * from websites where sal &gt;&#x3D; 0 and sal &lt;&#x3D;2000 ; -- 收入在 0 到 2000 之间select * from websites where sal between 0 and 2000； -- 和上面一样的，没事找事select * from websites where sal &lt; 5 or sal is null ; -- 收入小于5 或者没收入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意： null 的条件判断用 is null 或 is not null</p></blockquote><h3 id="order-by">order by</h3><p>排序: 默认情况下是升序，asc 可以省略 。</p><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">select * from websites order by sal asc,alexa desc ;-- 先根据sal 升序排序，再根据 alexa 降序<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="like-和-通配符">like 和 通配符</h3><blockquote><ul><li>like 模糊查询</li><li>通配符<ul><li>% ： 0个或多个字符</li><li>_ : 1 个字符</li></ul></li></ul></blockquote><h3 id="in">in</h3><ul><li>匹配多个条件</li></ul><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">select * from websites where country in (&#39;USA&#39;,&#39;鸟国&#39;,&#39;CN&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>等价于</li></ul><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">select * from websites where country &#x3D; &#39;USA&#39; or country &#x3D; &#39;鸟国&#39; or country &#x3D; &#39;CN&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="别名">别名</h3><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">select tt.name &#39;网站名字&#39; from websites tt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Group-by-分组查询">Group by 分组查询</h4><blockquote><p>注意：分组时候的筛选用 having</p><p>常见的几个组函数： max() min() avg() count() sum()</p></blockquote><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">select avg(sal) aa from websites where sal is not null group by country having aa &gt; 1500<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="连接查询">连接查询</h3><pre class="line-numbers language-sqlite" data-language="sqlite"><code class="language-sqlite">select name,count,date from websites w , access_log a ; -- 著名的笛卡尔积，没什么意义的select name,count,date from websites w , access_log a where w.id &#x3D; a.site_id；-- 这是 1992的语法select name,count,date from websites w inner join access_log a on w.id &#x3D; a.site_id；-- 这是1999 年的语法，推荐使用select name,count,date from websites w left outer join access_log a on w.id &#x3D; a.site_id；-- 把没有访问的网站也显示出来-- 注意: inner 和 outer 是可以默认省略的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MySQL的数据类型&quot;&gt;MySQL的数据类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。&lt;/li&gt;
&lt;li&gt;备注: char 和varchar 一定要指定长度，float 会自动提升为double，</summary>
      
    
    
    
    <category term="后端" scheme="https://www.alexation.cn/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MySQL" scheme="https://www.alexation.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>拥抱FastAPI</title>
    <link href="https://www.alexation.cn/backend/fastapi/"/>
    <id>https://www.alexation.cn/backend/fastapi/</id>
    <published>2022-04-24T09:03:37.000Z</published>
    <updated>2022-04-28T09:34:36.025Z</updated>
    
    <content type="html"><![CDATA[<p>FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，使用 Python 3.6+ 并基于标准的 Python 类型提示。</p><p>关键特性:</p><ul><li><strong>快速</strong>：可与 <strong>NodeJS</strong> 和 <strong>Go</strong> 比肩的极高性能（归功于 Starlette 和 Pydantic）。<a href="https://fastapi.tiangolo.com/zh/#_11">最快的 Python web 框架之一</a>。</li><li><strong>高效编码</strong>：提高功能开发速度约 200％ 至 300％。*</li><li><strong>更少 bug</strong>：减少约 40％ 的人为（开发者）导致错误。*</li><li><strong>智能</strong>：极佳的编辑器支持。处处皆可自动补全，减少调试时间。</li><li><strong>简单</strong>：设计的易于使用和学习，阅读文档的时间更短。</li><li><strong>简短</strong>：使代码重复最小化。通过不同的参数声明实现丰富功能。bug 更少。</li><li><strong>健壮</strong>：生产可用级别的代码。还有自动生成的交互式文档。</li><li><strong>标准化</strong>：基于（并完全兼容）API 的相关开放标准：<a href="https://github.com/OAI/OpenAPI-Specification">OpenAPI</a> (以前被称为 Swagger) 和 <a href="https://json-schema.org/">JSON Schema</a>。</li></ul><p>* 根据对某个构建线上应用的内部开发团队所进行的测试估算得出。</p><p>上一次的全栈项目自动安全上报后端启用的是flask，这次让我们来拥抱FastAPI！</p><p>官网文档：<a href="https://fastapi.tiangolo.com/zh/">FastAPI (tiangolo.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，使用 Python 3.6+ 并基于标准的 Python 类型提示。&lt;/p&gt;
&lt;p&gt;关键特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;快速&lt;/strong&gt;：可与 &lt;strong&gt;NodeJ</summary>
      
    
    
    
    <category term="后端" scheme="https://www.alexation.cn/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="FastAPI" scheme="https://www.alexation.cn/tags/FastAPI/"/>
    
    <category term="后端" scheme="https://www.alexation.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Python" scheme="https://www.alexation.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CTGU自动打卡</title>
    <link href="https://www.alexation.cn/frontend/Yiqing/"/>
    <id>https://www.alexation.cn/frontend/Yiqing/</id>
    <published>2022-02-14T04:37:09.000Z</published>
    <updated>2022-04-28T09:30:23.095Z</updated>
    
    <content type="html"><![CDATA[<h1 style="text-align:center;font-weight:700;color:#B399FF"><i>CTGU自动安全上报</i></h1><p>项目名称：CTGU自动安全上报</p><p>所使用技术栈：Vue2 + Flask + MySQL</p><p>实现过程：用户通过提交表单数据到Flask提供的API接口，将学号密码存储到MySQL数据库中，再通过服务器端Python脚本每天调用数据库参数对CTGU安全上报接口进行请求，达到自动安全上报。</p><p>源码地址：<a href="https://github.com/Alexation/Yiqing">Alexation/Yiqing: CTGU Auto Safety Report (github.com)</a></p><p>实现过程大致分为三个阶段：</p><ol><li>自动安全上报脚本编写</li><li>前端用户信息收集</li><li>后端提供API接口</li></ol><h2 id="自动安全上报脚本编写">自动安全上报脚本编写</h2><h3 id="Python脚本构造思路">Python脚本构造思路</h3><h4 id="1-明确需求（Website）">1.明确需求（Website）</h4><h4 id="2-发送请求（Request）">2.发送请求（Request）</h4><ul><li>请求方式：Get、Post</li><li>请求URL：URL全称统一资源定位符，如一个网页文档、一张图片、一个视频等都可以用URL唯一来确定</li><li>请求头：头部信息如User-Agent、Host、Cookies等信息</li><li>请求体：请求时额外携带的数据，如表单提交时的表单数据</li></ul><h4 id="3-获取数据（Response）">3.获取数据（Response）</h4><ul><li>响应状态：有多种响应状态，如200代表成果、301跳转、404找不到页面、502服务器错误等</li><li>响应头：如内容类型、内容长度、服务器信息、设置Cookie等</li><li>响应体：最主要的部分、包含了请求资源的内容，如网页的HTML、图片的二进制数据等</li></ul><h4 id="4-解析数据（Parse）">4.解析数据（Parse）</h4><ul><li>直接处理</li><li>Json解析</li><li>正则表达式</li><li>BeautifulSoup</li><li>Parsel</li><li>Xpath/CSS</li></ul><h4 id="5-存储数据（Database）">5.存储数据（Database）</h4><ul><li>文本：如纯文本、Json、Xml等</li><li>关系型数据库：如MySQL、Orcacle、SQL Server等</li><li>非关系型数据库：如MongoDB、Redis等key-value形式储存</li><li>二进制文件：如图片、视频、音频等直接保存成特定文件格式</li></ul><h3 id="根据网页结构编写代码">根据网页结构编写代码</h3><p>来到登录页面按下F12并刷新网页，因为登录涉及跳转甚至重定向，因此要勾选Preserve log选项。</p><h3 id=""><img src="https://s2.loli.net/2022/02/15/syrAFtjGVi95b4f.png" alt=""></h3><p>实际抓包过程中，我们发现登录的Post请求并没有返回相应的关键字段，但是我们发现cookie字段中含有JSESSION便可推断当我们访问登录页面时，服务器返回JSESSION，之后通过我们登陆时的JSESSION对相应的账户进行匹配，于是我们可以直接构造Session对象维持会话。</p><p><img src="https://s2.loli.net/2022/02/15/lOJvXWRuxNEbnCs.png" alt=""></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Origin Headersheaders &#x3D; &#123;    &#39;Host&#39;: &#39;yiqing.ctgu.edu.cn&#39;,    &#39;Referer&#39;: &#39;http:&#x2F;&#x2F;yiqing.ctgu.edu.cn&#x2F;wx&#x2F;index&#x2F;main.do?currSchool&#x3D;ctgu&amp;CURRENT_YEAR&#x3D;2019&amp;showWjdc&#x3D;false&amp;studentShowWjdc&#x3D;false&#39;,    # &#39;Upgrade-Insecure-Requests&#39;: &#39;1&#39;,    &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;97.0.4692.99 Safari&#x2F;537.36&#39;,&#125;# 获取服务器端 JSESSIONIDsession &#x3D; requests.Session()session_url &#x3D; &#39;http:&#x2F;&#x2F;yiqing.ctgu.edu.cn&#x2F;wx&#x2F;health&#x2F;main.do&#39;response_session &#x3D; session.get(url&#x3D;session_url, headers&#x3D;headers, allow_redirects&#x3D;False)# post datadata &#x3D; &#123;    &#39;username&#39;: username,    &#39;password&#39;: password,&#125;# 模拟登录请求，进行 JSESSIONID 账号配对login_url &#x3D; &#39;http:&#x2F;&#x2F;yiqing.ctgu.edu.cn&#x2F;wx&#x2F;index&#x2F;loginSubmit.do&#39;response_data &#x3D; session.post(url&#x3D;login_url, data&#x3D;data).textprint(&#39;登录状态: &#39; + response_data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>登录成功返回success，失败返回false。后续我们可以通过该接口返回值对有效用户进行筛选。接下来我们利用该session请求提交页面拿到隐藏的token</p><p><img src="https://s2.loli.net/2022/02/15/IjUKrvb13AF2YiD.png" alt=""></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Get tokenapply_url &#x3D; &#39;http:&#x2F;&#x2F;yiqing.ctgu.edu.cn&#x2F;wx&#x2F;health&#x2F;toApply.do&#39;apply_response &#x3D; session.get(url&#x3D;apply_url).text# 判断是否已提交请求，如果已经提交的话服务器便不再响应if re.findall(&#39;&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;ttoken&quot; value&#x3D;&quot;(.*?)&quot;&#x2F;&gt;&#39;, apply_response):token &#x3D; re.findall(&#39;&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;ttoken&quot; value&#x3D;&quot;(.*?)&quot;&#x2F;&gt;&#39;, apply_response)[0]# 获取上一次提交数据进行构造请求before_url &#x3D; &#39;http:&#x2F;&#x2F;yiqing.ctgu.edu.cn&#x2F;wx&#x2F;health&#x2F;studentHis.do&#39;before_data &#x3D; session.post(url&#x3D;before_url, data&#x3D;data).textbefore_data_json &#x3D; json.loads(before_data)# 构造提交参数data_submit &#x3D; &#123;&#39;ttoken&#39;: token,&#39;province&#39;: before_data_json[0][&#39;province&#39;],&#39;city&#39;: before_data_json[0][&#39;city&#39;],&#39;district&#39;: before_data_json[0][&#39;district&#39;],&#39;adcode&#39;: before_data_json[0][&#39;adcode&#39;],&#39;longitude&#39;: before_data_json[0][&#39;longitude&#39;],&#39;latitude&#39;: before_data_json[0][&#39;latitude&#39;],&#39;sfqz&#39;: before_data_json[0][&#39;sfqz&#39;],&#39;sfys&#39;: before_data_json[0][&#39;sfys&#39;],&#39;sfzy&#39;: before_data_json[0][&#39;sfzy&#39;],&#39;sfgl&#39;: before_data_json[0][&#39;sfgl&#39;],&#39;status&#39;: before_data_json[0][&#39;status&#39;],&#39;szdz&#39;: before_data_json[0][&#39;szdz&#39;],&#39;sjh&#39;: before_data_json[0][&#39;sjh&#39;],&#39;lxrxm&#39;: before_data_json[0][&#39;lxrxm&#39;],&#39;lxrsjh&#39;: before_data_json[0][&#39;lxrsjh&#39;],&#39;sffr&#39;: before_data_json[0][&#39;sffr&#39;],&#39;sffrAm&#39;: before_data_json[0][&#39;sffrAm&#39;],&#39;sffrNoon&#39;: before_data_json[0][&#39;sffrNoon&#39;],&#39;sffrPm&#39;: before_data_json[0][&#39;sffrPm&#39;],&#39;sffy&#39;: before_data_json[0][&#39;sffy&#39;],&#39;sfgr&#39;: before_data_json[0][&#39;sfgr&#39;],&#39;qzglsj&#39;: before_data_json[0][&#39;qzglsj&#39;],&#39;qzgldd&#39;: before_data_json[0][&#39;qzgldd&#39;],&#39;glyy&#39;: before_data_json[0][&#39;glyy&#39;],&#39;mqzz&#39;: before_data_json[0][&#39;mqzz&#39;],&#39;sffx&#39;: before_data_json[0][&#39;sffx&#39;],&#39;qt&#39;: before_data_json[0][&#39;qt&#39;],&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>找到最后提交的URL进行请求即可</p><p><img src="https://s2.loli.net/2022/02/15/5x2f1q9jyeaA3mz.png" alt=""></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Final Submit APIurl &#x3D; &#39;http:&#x2F;&#x2F;yiqing.ctgu.edu.cn&#x2F;wx&#x2F;health&#x2F;saveApply.do&#39;submit &#x3D; session.post(url&#x3D;url, data&#x3D;data_submit).textsubmit_json &#x3D; json.loads(submit)print(&#39;提交状态：&#39; + submit_json[&#39;msgStatus&#39;])time.sleep(1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="对接MySQL数据库">对接MySQL数据库</h3><p>利用pymysql库将数据库信息拉到本地遍历请求即可</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    # Connect MySQL    connection &#x3D; pymysql.connect(host&#x3D;&#39;IP地址&#39;, user&#x3D;&#39;数据库用户&#39;, passwd&#x3D;&#39;数据库密码&#39;, port&#x3D;3306, db&#x3D;&#39;数据库名称&#39;, charset&#x3D;&#39;utf8&#39;)    cursor &#x3D; connection.cursor()    # Get user and password    cursor.execute(&#39;select * from yiqing&#39;)        # 收集所有用户信息    user_information &#x3D; cursor.fetchall()    # Disconnect MySQL    connection.commit()    cursor.close()    connection.close()except:    ErrorLog(&#39;Error---MySQL&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后端提供API接口">后端提供API接口</h2><h3 id="利用Flask搭建接口">利用Flask搭建接口</h3><p>Flask本身不限定数据库的选择，你可以选择SQL或NOSQL的任何一种。也可以选择更方便的SQLALchemy，类似于Django的ORM。SQLALchemy实际上是对数据库的抽象，让开发者不用直接和SQL语句打交道，而是通过Python对象来操作数据库，在舍弃一些性能开销的同时，换来的是开发效率的较大提升。</p><p>SQLAlchemy是一个关系型数据库框架，它提供了高层的ORM和底层的原生数据库的操作。<a href="https://flask-sqlalchemy.palletsprojects.com/en/master/quickstart/">Flask-SQLAlchemy</a>是一个简化了SQLAlchemy操作的flask扩展。</p><p>新建api.py文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from flask import Flask, render_templatefrom flask_sqlalchemy import SQLAlchemyapp &#x3D; Flask(__name__, static_url_path&#x3D;&#39;&#x2F;&#39;, static_folder&#x3D;&#39;.&#x2F;..&#x2F;..&#x2F;flask-dist&#39;, template_folder&#x3D;&#39;.&#x2F;..&#x2F;..&#x2F;flask-dist&#39;)app.config[&#39;SQLALCHEMY_DATABASE_URI&#39;] &#x3D; &#39;mysql+pymysql:&#x2F;&#x2F;name:pwd@106.13.174.205:3306&#x2F;mls_web&#39;# mysql+pymysql 这是声明数据库和链接数据库的引擎  # name pwd 就是可以访问数据库的用户名密码 # 106.13.174.205:3306 是数据库地址 # &#x2F;mls_web 这是数据库名字app.config[&#39;SQLALCHEMY_TRACK_MODIFICATIONS&#39;] &#x3D; True   如果设置成 True (默认情况)，Flask-SQLAlchemy 将会追踪对象的修改并且发送信号。这需要额外的内存， 如果不必要的可以禁用它。 db &#x3D; SQLAlchemy(app)声明数据对象@app.route(&#39;&#x2F;&#39;)def index():    return render_template(&#39;index.html&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run(debug&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install sqlacodegen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>cmd 切换到 flask目录 执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sqlacodegen --outfile&#x3D;models.py mysql+pymysql:&#x2F;&#x2F;name:pwd@106.13.174.205:3306&#x2F;mls_web<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成一个models.py文件 user表的映射，在该文件中，如果需要json格式传递，在class中添加如下代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def to_json(self):       return &#123;           &#39;id&#39;: self.id,           &#39;name&#39;: self.name,           &#39;pwd&#39;: self.pwd       &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将model.py引入api.py中</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from flask import Flask, render_template, jsonify, requestfrom flask_sqlalchemy import SQLAlchemyfrom models import *app &#x3D; Flask(__name__, static_url_path&#x3D;&#39;&#x2F;&#39;, static_folder&#x3D;&#39;.&#x2F;..&#x2F;..&#x2F;flask-dist&#39;, template_folder&#x3D;&#39;.&#x2F;..&#x2F;..&#x2F;flask-dist&#39;)app.config[&#39;SQLALCHEMY_DATABASE_URI&#39;] &#x3D; &#39;mysql+pymysql:&#x2F;&#x2F;mls:a838502774@106.13.174.205:3306&#x2F;mls_web&#39;app.config[&#39;SQLALCHEMY_TRACK_MODIFICATIONS&#39;] &#x3D; Trueapp.config[&#39;SQLALCHEMY_UCSO&#39;] &#x3D; Truedb &#x3D; SQLAlchemy(app)@app.route(&#39;&#x2F;&#39;)def index():    return render_template(&#39;index.html&#39;)@app.route(&#39;&#x2F;getUser&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])   # 查询数据的接口def get_user():    res &#x3D; db.session.query(User).all()#User是从models里导入的     temp &#x3D; []    for x in res:        temp.append(x.to_json())    return jsonify(data&#x3D;temp)@app.route(&#39;&#x2F;addUser&#39;, methods&#x3D;[&#39;POST&#39;])      #新增数据的接口def add_user():    data &#x3D; request.json        #获取传过来的参数    u &#x3D; User(name&#x3D;data.get(&quot;name&quot;),pwd&#x3D;data.get(&quot;pwd&quot;))      #根据传过来参数创建一条数据    db.session.add(u)  #add 是增加数据    db.session.commit()   #提交了才会到数据库中    return &#39;success&#39;if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run(debug&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Flask解决跨域问题">Flask解决跨域问题</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install flask-cors<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>flask-cors 有两种用法，一种为全局使用，一种对指定的路由使用</p><p>配置全局路由</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from flask import Flask, requestfrom flask_cors import CORSapp &#x3D; Flask(__name__)CORS(app, supports_credentials&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置单行路由</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from flask import Flask, requestfrom flask_cors import cross_originapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;&#39;)@cross_origin(supports_credentials&#x3D;True)def hello():    name &#x3D; request.args.get(&quot;name&quot;, &quot;World&quot;)    return f&#39;Hello, &#123;name&#125;!&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="服务器后台挂起">服务器后台挂起</h3><p>到这里接口已经可以正常访问了，但是当程序退出时无法访问，这里我使用gunicorn将flask挂起到后台</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装最新版本的gunicornpip install gunicorn#安装指定版本的gunicornpip install gunicorn&#x3D;&#x3D;19.9.0#异步模式pip install gevent&#x3D;&#x3D;1.4.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义常用的配置文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!usr&#x2F;bin&#x2F;env python#encoding:utf-8  import osimport gevent.monkeygevent.monkey.patch_all()import multiprocessing  #开发环境可以打开，生产环境可以#debug &#x3D; True   #用于控制errorlog的信息级别，可以设置为debug、info、warning、error、criticalloglevel &#x3D; &#39;debug&#39; #监听地址+端口bind &#x3D; &quot;0.0.0.0:5000&quot; #定义日志存储if not os.path.exists(&#39;log&#x2F;&#39;):    os.makedirs(&#39;log&#x2F;&#39;)pidfile &#x3D; &quot;log&#x2F;gunicorn.pid&quot;#访问日志accesslog &#x3D; &quot;log&#x2F;access.log&quot;#错误日志errorlog &#x3D; &quot;log&#x2F;debug.log&quot; #开启后台运行，默认值为Falsedaemon &#x3D; True #启动的进程数，推荐值为：CPU核数*2+1workers &#x3D; multiprocessing.cpu_count()*2+1 #指开启的每个工作进程的模式类型，默认为sync模式，也可使用gevent模式worker_class &#x3D; &#39;gevent&#39;x_forwarded_for_header &#x3D; &#39;X-FORWARDED-FOR&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动方式</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 第一种gunicorn -w 4 -b 172.19.6.213:5000 api:app# 第二种gunicorn --config&#x3D;config.py api:app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果出现占用情况，可先查看pid然后关停即可</p><pre class="line-numbers language-none"><code class="language-none">netstat -tulpn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4096即为占位端口的pid</p><pre class="line-numbers language-none"><code class="language-none">kill -9 4096<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="前端用户信息收集">前端用户信息收集</h2><p>因为仅仅是收集用户的学号和密码，故不需要router以及vuex等组件，也不需要对axios进行二次封装，所以这里我采用ElementUI的一个表单组件。再通过对样式进行微调，为了放置页面过于单调，为其添加一个SVG的动态背景。</p><p>本地调试的时候由于可以通过后端解决跨域问题，便不再对vue.config.js进行更改，不过需要注意的是要在里面更改页面title</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// vue.config.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//关闭es6</span>  lintOnSave<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token function-variable function">chainWebpack</span><span class="token operator">:</span> <span class="token parameter">config</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    config      <span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'html'</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token parameter">args</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>title<span class="token operator">=</span><span class="token string">'CTGU自动安全上报'</span>        <span class="token keyword">return</span> args      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于ElementUI的按需引入需要在babel.config.js文件里添加配置，包括message也要挂载到vue原型上，这些<a href="https://element.eleme.io/#/zh-CN/component/quickstart">ElementUI官方文档</a>都有的。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// babel.config.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  presets<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'@vue/cli-plugin-babel/preset'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token string">"modules"</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span>      <span class="token string">"component"</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span>        <span class="token string">"libraryName"</span><span class="token operator">:</span> <span class="token string">"element-ui"</span><span class="token punctuation">,</span>        <span class="token string">"styleLibraryName"</span><span class="token operator">:</span> <span class="token string">"theme-chalk"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>向API提交表单，提交的数据格式要和后台接口统一，不然解析后数据可能为空。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// login.vue</span><span class="token comment">// 设置数据格式</span><span class="token keyword">const</span> headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token string">"Content-Type"</span><span class="token operator">:</span> <span class="token string">"multipart/form-data"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 构造表单</span><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>data<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ruleForm<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>data<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ruleForm<span class="token punctuation">.</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 发请求</span><span class="token keyword">this</span><span class="token punctuation">.</span>$axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">"后台数据库地址"</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>headers<span class="token operator">:</span> headers<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token comment">// console.log(res)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 提交完毕后重置表格，避免重复提交</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">[</span>formName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resetFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>剩下的就是完善一些细节，比如如何取消自动上报的一些信息以及用户操作完毕后的及时反馈。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// login.vue</span><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$message</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        showClose<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        message<span class="token operator">:</span> <span class="token string">"注意：更改密码即可取消自动安全上报"</span><span class="token punctuation">,</span>        type<span class="token operator">:</span> <span class="token string">"info"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 style=&quot;text-align:center;font-weight:700;color:#B399FF&quot;&gt;&lt;i&gt;CTGU自动安全上报&lt;/i&gt;&lt;/h1&gt;
&lt;p&gt;项目名称：CTGU自动安全上报&lt;/p&gt;
&lt;p&gt;所使用技术栈：Vue2 + Flask + MySQL&lt;/p&gt;</summary>
      
    
    
    
    <category term="Project" scheme="https://www.alexation.cn/categories/Project/"/>
    
    
    <category term="MySQL" scheme="https://www.alexation.cn/tags/MySQL/"/>
    
    <category term="Vue" scheme="https://www.alexation.cn/tags/Vue/"/>
    
    <category term="跨域" scheme="https://www.alexation.cn/tags/%E8%B7%A8%E5%9F%9F/"/>
    
    <category term="Flask" scheme="https://www.alexation.cn/tags/Flask/"/>
    
    <category term="全栈" scheme="https://www.alexation.cn/tags/%E5%85%A8%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>JS混淆与反混淆</title>
    <link href="https://www.alexation.cn/javascript/JsCoder/"/>
    <id>https://www.alexation.cn/javascript/JsCoder/</id>
    <published>2022-01-25T11:57:33.000Z</published>
    <updated>2022-04-28T09:28:52.296Z</updated>
    
    <content type="html"><![CDATA[<h1>js混淆的利与弊</h1><p><strong>站在网站开发者的角度</strong></p><p>1、是为了保护我们的前端代码逻辑<br>2、精简代码、加快传输</p><p><strong>站在爬虫者的角度</strong></p><p>1、增加了获取数据的难度</p><h1>常见混淆与反混淆方法</h1><h2 id="JS压缩">JS压缩</h2><p>特征：</p><p><img src="https://s2.loli.net/2022/01/25/ATSCpEHNG3Rxzhq.png" alt=""></p><p>原理：<br>削减是一个从源代码中删除不必要的字符的技术使它看起来简单而整洁。这种技术也 被称为代码压缩和最小化</p><h2 id="eval加密">eval加密</h2><p>js中的 eval() 方法就是一个 js 语言的执行器，它能把其中的参数按照 JavaScript 语法进行解析并执行，简单来说就是把原本的 js 代码变成了 eval 的参数，变成参数后代码就成了字符串，其中的一些字符就会被按照特定格式“编码”</p><p><strong>特征：</strong></p><p>最明显的特征是生成的代码以 eval(function(p,a,c,k,e,r)) 开头</p><p><img src="https://s2.loli.net/2022/01/25/xuv49CpL5Zm3XdM.png" alt=""></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">eval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">200</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>原理：</strong></p><p>这类混淆的关键思想在于将需要执行的代码进行一次编码，在执行的时候还原出浏览器可执行的合法 的脚本</p><p><strong>破解方法-浏览器</strong><br>打开 谷歌 或者 火狐 浏览器<br>按 F12 打开控制台<br>把代码复制进去<br>删除开头 eval 这4个字母<br>按回车键</p><p><strong>破解方法-node.js</strong></p><p>将eval 的内容转变为普通的函数</p><h2 id="变量名混淆">变量名混淆</h2><p><img src="https://s2.loli.net/2022/01/25/MFHaX2eKUZLvtpE.png" alt=""></p><p><strong>原理：</strong></p><p><strong>字符串字面量混淆：</strong> 首先提取全部的字符串，在全局作用域创建一个字符串数组，同时转义字符增大 阅读难度，然后将字符串出现的地方替换成为数组元素的引用</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">var _0x3012 &#x3D; [&#39;substring&#39;, &#39;atob&#39;, &#39;charCodeAt&#39;, &#39;push&#39;, &#39;test&#39;];&#x2F;&#x2F; 打乱数组的内容(function(_0x3ed35c, _0x48b8fe) &#123;    var _0x1ad9d9 &#x3D; function(_0x8eeda7) &#123;        while (--_0x8eeda7) &#123;            _0x3ed35c[&#39;push&#39;](_0x3ed35c[&#39;shift&#39;]());        &#125;    &#125;;    _0x1ad9d9(++_0x48b8fe);&#125;(_0x3012, 0x153));&#x2F;&#x2F; 用函数实现字符串的调用var _0x3a8e &#x3D; function(_0xc40c11, _0x32bbb2) &#123;    _0xc40c11 &#x3D; _0xc40c11 - 0x0;    var _0x4e269a &#x3D; _0x3012[_0xc40c11];    return _0x4e269a;&#125;;console.log(_0x3a8e(&#39;0x4&#39;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**变量名混淆：**不同于压缩器的缩短命名，此处使用了下划线加数字的格式，变量之间区分度很低，相 比单个字母更难以阅读</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;*变量名混淆*&#x2F;var _0x3a8e &#x3D; function(_0xc40c11, _0x32bbb2) &#123;    _0xc40c11 &#x3D; _0xc40c11 - 0x0;    var _0x4e269a &#x3D; _0x3012[_0xc40c11];    return _0x4e269a;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**成员运算符混淆：**将点运算符替换为字符串下标形式，然后对字符串进行混淆删除多余的空白字符：减小文件体积，这是所有压缩器都会做的事</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;*成员运算符混淆*&#x2F;console.log((&#39;&#39;)[&#39;\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72&#39;][&#39;\x66\x72\x6f\x6d\x43\x68\x61\x72\x43\x6f\x64\x65&#39;](65));console.log((&#39;&#39;)[&#39;constructor&#39;][&#39;fromCharCode&#39;](65));console.log(&#39;&#39;.constructor.fromCharCode(65))console.log(&#39;&#39;.constructor)console.log(String.fromCharCode(65));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>破解方法-IDE、解密工具、浏览器：特殊字符变成普通内容</p><p><strong>特征：</strong></p><p><img src="https://s2.loli.net/2022/01/25/QPW1Ve8H6wFBGZu.png" alt=""></p><ol><li><p>把变量名、函数名、参数名等，替换成没有语义，看着又很像的名字。</p><pre class="line-numbers language-none"><code class="language-none">_0x21dd83、_0x21dd84、_0x21dd85<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>用十六进制文本去表示一个字符串</p><pre class="line-numbers language-none"><code class="language-none">\x56\x49\x12\x23<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>利用JS能识别的编码来做混淆。JS是Unicode编码，本身就能识别这种编码。类似的一些变量名，函数名都可以用这个表示，并且调用。</p></li></ol><p>类似:</p><p><code>\u6210\u529f</code> 表示中文字符(成功)。</p><p>类似:</p><p><code>\u0053\u0074\u0072\u0069\u006e\u0067.\u0066\u0072\u006f\u006d\u0043\u0068\u0061\u0072\u0043\u006f\u0064\u0065</code>  代表 String.fromCharCode</p><p>类似：</p><p><code>('')['\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72']['\x66\x72\x6f\x6d\x43\x68\x61\x72\x43\x6f\x64\x65'];</code> 效果等同于String.fromCharCode</p><ol start="4"><li><p>把一大堆方法名、字符串等存到数组中，这个数组可以是上千个成员。然后调用的时候，取数组成员去用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Date"</span><span class="token punctuation">,</span><span class="token string">"getTime"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> time <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">window</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>字符串加密后发送到前端，然后前端调用对应的函数去解密，得到明文</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'xxxx'</span><span class="token punctuation">]</span><span class="token comment">// 定义的解密函数</span><span class="token keyword">function</span> <span class="token function">dec</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token string">'push'</span><span class="token punctuation">&#125;</span>test<span class="token punctuation">[</span><span class="token function">dec</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="控制流平坦化">控制流平坦化</h2><p>将顺序执行的代码混淆成乱序执行,并加以混淆</p><p>以下两段代码的执行结果是相同的:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 正常形态</span><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>    b <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    b <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>    b <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">;</span>    b <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">&#125;</span><span class="token comment">// 乱序形态</span><span class="token comment">//（这里比较简单,在很多加密网站上case 后面往往不是数字或字符串,而是类似 YFp[15][45][4]这样的对象，相当恶心）</span><span class="token keyword">function</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>lenght<span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>        b <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>        b <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>        <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>        b <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b      <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>        b <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 结果都是30 但是test1看着费劲</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">test1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决办法:  使用JavaScript的抽象语法书(AST) 进行还原</p><h2 id="压缩代码">压缩代码</h2><p>把多行代码压缩成一行</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token keyword">var</span> c <span class="token operator">=</span> b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> d <span class="token operator">=</span> b <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> e <span class="token operator">=</span> b <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> f <span class="token operator">=</span> b <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> e <span class="token operator">+</span> f<span class="token punctuation">&#125;</span><span class="token comment">// 压缩一下</span><span class="token keyword">function</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">,</span>e<span class="token punctuation">,</span>f  <span class="token keyword">return</span> f <span class="token operator">=</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token punctuation">(</span>d <span class="token operator">=</span> <span class="token punctuation">(</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> a<span class="token punctuation">,</span>b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>b <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>b <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>b <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>e <span class="token operator">+</span> f<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决办法:  使用JavaScript的抽象语法书(AST) 进行还原</p><h2 id="使用特定符号编写-js-脚本">使用特定符号编写 js 脚本</h2><p>特征：</p><p><img src="https://s2.loli.net/2022/01/25/JVOQbp4TcguLfhk.png" alt="image-20191225190724159"></p><p>原理：<br>jsfuck 源于一门编程语言 brainfuck ，其主要的思想就是只使用8种特定的符号来编写代码。而 jsfuck<br>也是沿用了这个思想，它仅仅使用6种符号来编写代码。它们分别是(、)、+、[、]、!。<br>常用混淆工具：<br><a href="http://www.jsfuck.com/">http://www.jsfuck.com/</a><br>破解方法： 无</p><h1>特殊转化规则</h1><p>利用一些只能在浏览器中运行的特殊语句进行反扒，这种只能讲语法重新进行改写</p><p>在浏览器中 base64 编码转换使用的是</p><p><code>_0x1c0cdf = _0xcbc80b['atob'](_0x1c0cdf)</code>,</p><p>但是在nodejs调试的时候使用的是</p><pre class="line-numbers language-none"><code class="language-none">Buffer.from(_0x1c0cdf,&quot;base64&quot;).toString()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://xyq.cbg.163.com/equip?s=40&amp;eid=202002011900113-40-NXOJDHZ8TKFX9&amp;o&amp;equip_refer=27&amp;view_loc=reco_sim%7C%7B%22tag%22%3A%20%22RL_sim2%22%7D">https://xyq.cbg.163.com/equip?s=40&amp;eid=202002011900113-40-NXOJDHZ8TKFX9&amp;o&amp;equip_refer=27&amp;view_loc=reco_sim|{&quot;tag&quot;%3A &quot;RL_sim2&quot;}</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;js混淆的利与弊&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;站在网站开发者的角度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、是为了保护我们的前端代码逻辑&lt;br&gt;
2、精简代码、加快传输&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;站在爬虫者的角度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、增加了获取数据的难</summary>
      
    
    
    
    <category term="加密算法" scheme="https://www.alexation.cn/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Javascript" scheme="https://www.alexation.cn/tags/Javascript/"/>
    
    <category term="混淆" scheme="https://www.alexation.cn/tags/%E6%B7%B7%E6%B7%86/"/>
    
    <category term="反混淆" scheme="https://www.alexation.cn/tags/%E5%8F%8D%E6%B7%B7%E6%B7%86/"/>
    
  </entry>
  
  <entry>
    <title>常见加密方式</title>
    <link href="https://www.alexation.cn/javascript/Coder/"/>
    <id>https://www.alexation.cn/javascript/Coder/</id>
    <published>2022-01-25T10:57:33.000Z</published>
    <updated>2022-01-25T13:39:34.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>我们所说的加密方式，都是对二进制编码的格式进行加密的，对应到Python中，则是我们的<code>Bytes</code>。</p><p>所以当我们在Python中进行加密操作的时候，要确保我们操作的是<code>Bytes</code>，否则就会报错。</p><p>将字符串和<code>Bytes</code>互相转换可以使用<code>encode()</code>和<code>decode()</code>方法。如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 方法中不传参数则是以默认的utf-8编码进行转换a &#x3D; &quot;中国欢迎您&quot;.encode(&quot;utf-8&quot;)print(a)  # b&#39;\xe4\xb8\xad\xe5\x9b\xbd\xe6\xac\xa2\xe8\xbf\x8e\xe6\x82\xa8&#39;b &#x3D; a.decode(&quot;utf-8&quot;)print(b)  # 中国欢迎您<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注：两位十六进制常常用来显示一个二进制字节。</strong></p><p>利用<code>binascii</code>模块可以将十六进制显示的字节转换成我们在加解密中更常用的显示方式：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import binascii# 方法中不传参数则是以默认的utf-8编码进行转换a &#x3D; &quot;中国欢迎您&quot;.encode(&quot;utf-8&quot;)print(a)  # b&#39;\xe4\xb8\xad\xe5\x9b\xbd\xe6\xac\xa2\xe8\xbf\x8e\xe6\x82\xa8&#39;b &#x3D; a.decode(&quot;utf-8&quot;)print(b)  # 中国欢迎您# 二进制到十二进制c &#x3D; binascii.b2a_hex(&#39;中国欢迎您&#39;.encode())print(&quot;c&quot;, c)  # c&#x3D;&#x3D;&#x3D; b&#39;e4b8ade59bbde6aca2e8bf8ee682a8&#39;# 十六进制到二进制d &#x3D; binascii.a2b_hex(c)print(d)  # b&#39;\xe4\xb8\xad\xe5\x9b\xbd\xe6\xac\xa2\xe8\xbf\x8e\xe6\x82\xa8&#39;v &#x3D; binascii.a2b_hex(c).decode(&quot;utf-8&quot;)print(v)  # 中国欢迎您b &#x3D; a.decode(&quot;utf-8&quot;)print(b)  # 中国欢迎您<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="URL编码">URL编码</h3><p><strong>1、简介</strong></p><p>正常的URL中是只能包含ASCII字符的，也就是字符、数字和一些符号。而URL编码就是一种浏览器用来避免url中出现特殊字符（如汉字）的编码方式。其实就是将超出ASCII范围的字符转换成带<code>%</code>的十六进制格式。</p><p><strong>2、Python实现</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib import parse# 编码a &#x3D; parse.quote(&quot;中国欢迎您&quot;)print(a)  # %E4%B8%AD%E5%9B%BD%E6%AC%A2%E8%BF%8E%E6%82%A8# 解码b &#x3D; parse.unquote(a)print(b)  # 中国欢迎您<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Base64编码">Base64编码</h3><p><strong>1、简介</strong></p><p>Base64是一种用64个字符来表示任意二进制数据的方法。</p><p>Base64编码可以成为密码学的基石。可以将任意的二进制数据进行Base64编码。所有的数据都能被编码为并只用65个字符就能表示的文本文件。（ 65字符：A~Z a~z 0~9 + / = ）编码后的数据~=编码前数据的4/3，会大1/3左右。</p><p><strong>2、Base64编码的原理</strong></p><p><img src="https://s2.loli.net/2022/01/25/cPkQK3IM97vtbsj.jpg" alt="aryxq-axx4s"></p><ol><li>将所有字符转化为ASCII码。</li><li>将ASCII码转化为8位二进制 。</li><li>将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位。</li><li>统一在6位二进制前补两个0凑足8位。</li><li>将补0后的二进制转为十进制。</li><li>从Base64编码表获取十进制对应的Base64编码。</li></ol><p><strong>3、Base64编码的说明</strong></p><ol><li>转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。</li><li>数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择查表选择对应的字符作为编码后的输出。</li><li>不断进行，直到全部输入数据转换完成。</li><li>如果最后剩下两个输入数据，在编码结果后加1个“=”。</li><li>如果最后剩下一个输入数据，编码结果后加2个“=”。</li><li>如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。</li></ol><p><strong>4、Python的Base64使用</strong></p><p>Python内置的<code>base64</code>模块可以直接进行base64的编解码</p><p><strong>注意：用于base64编码的，要么是ASCII包含的字符，要么是二进制数据</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import base64# 编码a &#x3D; base64.b64encode(b&quot;hello world&quot;)print(a)  # b&#39;aGVsbG8gd29ybGQ&#x3D;&#39;# 解码b &#x3D; base64.b64decode(a)print(b)  # b&quot;hello world&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5、Base64格式的文件</strong></p><p>在前端中，有很多文件也被编辑成base的文件，使用这种格式也可以进行还原</p><h3 id="MD5（信息-摘要算法）">MD5（信息-摘要算法）</h3><p><strong>1、简述</strong></p><p>message-digest algorithm 5（信息-摘要算法）。经常说的“MD5加密”，就是它→信息-摘要算法。</p><p>md5，其实就是一种算法。可以将一个字符串，或文件，或压缩包，执行md5后，就可以生成一个固定长度为128bit 的串。这个串，基本上是唯一的。</p><p><strong>2、不可逆性</strong></p><p>每个人都有不同的指纹，看到这个人，可以得出他的指纹等信息，并且唯一对应，但你只看一个指纹，是不可能看到或读到这个人的长相或身份等信息。</p><p><strong>3、特点</strong></p><ol><li>压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li><li>容易计算：从原数据计算出MD5值很容易。</li><li>抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li><li>强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li></ol><p>举个栗子：我从树下捡了一片叶子，全世界有数不清的树叶，我就想整个世界会不会有一片完全一样的叶子? 以一片有限的叶子对世界上无限的树叶，这个理论上的确是可以找到一片完全的叶子，可是实际情况下很难很难找到。</p><p><strong>4、Python的MD5使用</strong></p><p>由于MD5模块在python3中被移除，在python3中使用<code>hashlib</code>模块进行md5操作</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import hashlib# 待加密信息str &#x3D; &#39;中国你好&#39;# 创建md5对象，# md5对象，md5不能反解，但是加密是固定的，就是关系是一一对应，所以有缺陷，可以被对撞出来hl &#x3D; hashlib.md5()# 要对哪个字符串进行加密，就放这里# 此处必须声明encode# 若写法为hl.update(str)  报错为： Unicode-objects must be encoded before hashinghl.update(str.encode(encoding&#x3D;&#39;utf-8&#39;))print(&#39;MD5加密前为 ：&#39; + str)# hl.hexdigest()) #拿到加密字符串print(&#39;MD5加密后为 ：&#39; + hl.hexdigest())&quot;&quot;&quot;MD5加密前为 ：中国你好MD5加密后为 ：560a6b11a85d436acfa4bd7f34462f40&quot;&quot;&quot;hash3 &#x3D; hashlib.md5(bytes(&#39;abd&#39;, encoding&#x3D;&#39;utf-8&#39;))&#39;&#39;&#39; 如果没有参数，所以md5遵守一个规则，生成同一个对应关系，如果加了参数，就是在原先加密的基础上再加密一层，这样的话参数只有自己知道，防止被撞库，因为别人永远拿不到这个参数&#39;&#39;&#39;hash3.update(bytes(&quot;admin&quot;, encoding&#x3D;&quot;utf-8&quot;))print(hash3.hexdigest())  # 9aea3c0a6c51555c1a4d0a5e9b689ded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MD5不仅仅是上面这个例子这样用来处理字符串，还有更广泛的用途：</p><ul><li>加密网站注册用户的密码。 （但去年的各大网站密码泄漏事件确实让人蛋疼……）</li><li>网站用户上传图片 / 文件后，计算出MD5值作为文件名。（MD5可以保证唯一性）</li><li>key-value数据库中使用MD5值作为key。</li><li>比较两个文件是否相同。（大家在下载一些资源的时候，就会发现网站提供了MD5值，就是用来检测文件是否被篡改）</li><li>……</li></ul><p><strong>处理大文件：</strong></p><p>上面说过可以用MD5来检测两个文件是否相同，但想想，如果是两个很大的文件，担心内存不够用，这时怎么办？</p><p>这就要使用 update 方法了。代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import hashlib def get_file_md5(f):    m &#x3D; hashlib.md5()     while True:        data &#x3D; f.read(10240)        if not data:            break         m.update(data)    return m.hexdigest()  with open(YOUR_FILE, &#39;rb&#39;) as f:    file_md5 &#x3D; get_file_md5(f) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上的加密算法虽然非常厉害，但还是存在缺陷，即：通过撞库可以反解，所以，有必要对加密算法中添加自定义key再来做加密</p><p><strong>5、MD5长度</strong></p><p>md5的长度，默认为128bit，也就是128个0和1的二进制串。这样表达是很不友好的。所以将二进制转成了16进制，每4个bit表示一个16进制，所以128/4 = 32 换成16进制表示后，为32位了。</p><p>为什么网上还有md5是16位的呢？</p><p>其实16位的长度，是从32位md5值来的。是将32位md5去掉前八位，去掉后八位得到的。</p><p><strong>6、sha1 加密</strong></p><p>SHA1的全称是Secure Hash Algorithm(安全哈希算法) 。SHA1基于MD5，加密后的数据长度更长，</p><p>它对长度小于264的输入，产生长度为160bit的散列值。比MD5多32位。</p><p>因此，比MD5更加安全，但SHA1的运算速度就比MD5要慢了。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import hashlib str &#x3D; &quot;中国你好&quot;a &#x3D; hashlib.sha1(str.encode(&quot;utf-8&quot;)).hexdigest()print(&quot;sha1加密前为 ：&quot;,str)print(&quot;sha1加密前后 ：&quot;,a) &quot;&quot;&quot;sha1加密前为 ： 中国你好sha1加密前后 ： 3e6c570876775d0031dbf66247ed1054d4ef695e&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="PyCryptodome">PyCryptodome</h3><p>PyCrypto是 Python 中密码学方面最有名的第三方软件包。可惜的是，它的开发工作于2012年就已停止。</p><p>幸运的是，有一个该项目的分支 PyCrytodome 取代了 PyCrypto 。</p><h4 id="1、安装与导入">1、安装与导入</h4><p>安装之前需要先安装<strong>Microsoft Visual c++ 2015</strong>。</p><p>在Linux上安装，可以使用以下 pip 命令：</p><pre class="line-numbers language-none"><code class="language-none">pip install pycryptodome<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导入：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import Crypto<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在Windows 系统上安装则稍有不同：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install pycryptodomex<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导入：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import Cryptodome<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2、DES">2、DES</h4><p><strong>1)简介</strong></p><p>DES算法为密码体制中的对称密码体制，又被称为美国数据加密标准。</p><p>DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。</p><p>DES算法的入口参数有三个：Key、Data、Mode。其中Key为7个字节共56位，是DES算法的工作密钥；Data为8个字节64位，是要被加密或被解密的数据；Mode为DES的工作方式,有两种:加密或解密。</p><p>密钥长64位，密钥事实上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位，使得每个密钥都有奇数个1），分组后的明文组和56位的密钥按位替代或交换的方法形成密文组。</p><p>算法步骤<br>1）初始置换<br>其功能是把输入的64位数据块按位重新组合,并把输出分为L0、R0两部分,每部分各长3 2位,其置换规则为将输入的第58位换到第一位,第50位换到第2位……依此类推,最后一位是原来的第7位。L0、R0则是换位输出后的两部分，L0是输出的左32位,R0是右32位,例:设置换前的输入值为D1D2D3……D64,则经过初始置换后的结果为:L0=D58D50……D8;R0=D57D49……D7。<br>其置换规则见下表：<br>58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,<br>62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,<br>57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3,<br>61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7,<br>2）逆置换<br>经过16次迭代运算后,得到L16、R16,将此作为输入,进行逆置换,逆置换正好是初始置换的逆运算，由此即得到密文输出。<br>此算法是对称加密算法体系中的代表,在计算机网络系统中广泛使用.</p><p>加密和解密的过程</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 导入DES模块from Cryptodome.Cipher import DESimport binascii # 这是密钥,此处需要将字符串转为字节key &#x3D; b&#39;abcdefgh&#39; # 需要去生成一个DES对象def pad(text):     &quot;&quot;&quot;       # 加密函数，如果text不是8的倍数【加密文本text必须为8的倍数！】，那就补足为8的倍数        :param text:        :return:     &quot;&quot;&quot;     while len(text) % 8 !&#x3D; 0:        text +&#x3D; &#39; &#39;     return text # 创建一个DES实例des &#x3D; DES.new(key,DES.MODE_ECB)text &#x3D;&quot;I&#39;m china!&quot;padded_text &#x3D; pad(text)print(padded_text)#加密encrypted_text &#x3D; des.encrypt(padded_text.encode(&quot;utf-8&quot;))print(encrypted_text)# rstrip(&#39; &#39;)返回从字符串末尾删除所有字符串的字符串(默认空白字符)的副本 # 解密plain_text &#x3D; des.decrypt(encrypted_text).decode().rstrip(&#39; &#39;)print(plain_text) &quot;&quot;&quot;I&#39;m china!      b&#39;\xc0&#96;I\x15\x8bo\x00\x00\xb0\xe27\xfe)\xc3\xde,&#39;I&#39;m china!&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 导入DES模块from Cryptodome.Cipher import DESimport binascii # 这是密钥key &#x3D; b&#39;abcdefgh&#39;# 需要去生成一个DES对象des &#x3D; DES.new(key, DES.MODE_ECB)# 需要加密的数据text &#x3D; &#39;python spider!&#39;text &#x3D; text + (8 - (len(text) % 8)) * &#39;&#x3D;&#39;# 加密的过程encrypto_text &#x3D; des.encrypt(text.encode())# 加密过后二进制转化为ASCII encrypto_text &#x3D; binascii.b2a_hex(encrypto_text)print(encrypto_text)# 解密需要ASCII 先转化为二进制 然后再进行解密plaint &#x3D; des.decrypt(binascii.a2b_hex(encrypto_text))print(plaint) &quot;&quot;&quot;b&#39;084725d8f5ffafc61814fae0796bfd2f&#39;b&#39;python spider!&#x3D;&#x3D;&#39;&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、3DES">3、3DES</h4><p>3DES（或称为Triple DES）是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。它相当于是对每个数据块应用三次DES加密算法。</p><p>由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解。3DES即是设计用来提供一种相对简单的方法，即通过增加DES的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</p><p>3DES（即Triple DES）是DES向AES过渡的加密算法（1999年，NIST将3-DES指定为过渡的加密标准），加密算法，其具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，M代表明文，C代表密文，这样：</p><p>3DES加密过程为：C=Ek3(Dk2(Ek1(M)))</p><p>3DES解密过程为：M=Dk1(EK2(Dk3©))</p><h4 id="4、AES">4、AES</h4><p><strong>1）简介</strong></p><p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p><p>AES在软件及硬件上都能快速地加解密，相对来说较易于实作，且只需要很少的存储器。作为一个新的加密标准，目前正被部署应用到更广大的范围。<br>特点与思想：抵抗所有已知的攻击。 在多个平台上速度快，编码紧凑。 设计简单。</p><p><img src="https://s2.loli.net/2022/01/25/wBu6hHKlVs2EiOf.png" alt=""></p><p>AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同。</p><p>一般常用的是128位</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from Cryptodome.Cipher import AESfrom Cryptodome import Random from binascii import a2b_hex # 要加密的明文data &#x3D; &#39;南来北往&#39;# 密钥key必须为 16（AES-128）， 24（AES-192）， 32（AES-256）key &#x3D; b&#39;this is a 16 key&#39;# 生成长度等于AES 块大小的不可重复的密钥向量iv &#x3D; Random.new().read(AES.block_size)print(iv)# 使用 key 和iv 初始化AES 对象， 使用MODE_CFB模式mycipher &#x3D; AES.new(key, AES.MODE_CFB, iv)print(mycipher)# 加密的明文长度必须为16的倍数， 如果长度不为16的倍数， 则需要补足为16的倍数# 将iv(密钥向量)加到加密的密钥开头， 一起传输ciptext &#x3D; iv + mycipher.encrypt(data.encode())# 解密的话需要用key 和iv 生成的AES对象print(ciptext)mydecrypt &#x3D; AES.new(key, AES.MODE_CFB, ciptext[:16])# 使用新生成的AES 对象， 将加密的密钥解密decrytext &#x3D; mydecrypt.decrypt(ciptext[16:]) print(decrytext.decode())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="ECB模式">ECB模式</h5><p>ECB模式（电子密码本模式：Electronic codebook）</p><p>ECB是最简单的块密码加密模式，加密前根据加密块大小（如AES为128位）分成若干块，之后将每块使用相同的密钥单独加密，解密同理。</p><p><img src="https://s2.loli.net/2022/01/25/9IgSEAuJj1wvlHp.jpg" alt=""></p><p><strong>优缺点</strong></p><p>ECB模式作为一种基本工作模式，具有操作简单，易于实现的特点。同时由于其分组的独立性，利于实现并行处理，并且能很好地防止误差传播。</p><p>另一方面由于所有分组的加密方式一致，明文中的重复内容会在密文中有所体现，因此难以抵抗统计分析攻击。</p><p>因此，ECB模式一般只适用于小数据量的字符信息的安全性保护，例如密钥保护。</p><h5 id="CBC模式">CBC模式</h5><p>CBC模式（密码分组链接：Cipher-block chaining）</p><p>CBC模式对于每个待加密的密码块在加密前会先与前一个密码块的密文异或然后再用加密器加密。第一个明文块与一个叫初始化向量的数据块异或。</p><p><img src="https://s2.loli.net/2022/01/25/ORhX5fjd4sLrcvU.png" alt=""></p><h5 id="计算器模式">计算器模式</h5><p>计算器模式（Counter (CTR)）</p><p>计算器模式不常见，在CTR模式中，<br>有一个自增的算子，这个算子用密钥加密之后的输出和明文异或的结果得到密文，相当于一次一密。这种加密方式简单快速，安全可靠，而且可以并行加密，但是在计算器不能维持很长的情况下，密钥只能使用一次。CTR的示意图如下所示：</p><p><img src="https://s2.loli.net/2022/01/25/ME1WiNg5daJL2kB.png" alt=""></p><h5 id="密码反馈模式">密码反馈模式</h5><p>密码反馈模式（Cipher FeedBack (CFB)）</p><p>与ECB和CBC模式只能够加密块数据不同，CFB能够将块密文（Block Cipher）转换为流密文（Stream Cipher）。</p><p><img src="https://s2.loli.net/2022/01/25/Lf1nByvaoR9sUcA.png" alt=""></p><p>注意:CFB、OFB和CTR模式中解密也都是用的加密器而非解密器。<br>CFB的加密工作分为两部分：</p><p>将一前段加密得到的密文再加密；<br>将第1步加密得到的数据与当前段的明文异或。<br>由于加密流程和解密流程中被块加密器加密的数据是前一段密文，因此即使明文数据的长度不是加密块大小的整数倍也是不需要填充的，这保证了数据长度在加密前后是相同的。</p><h4 id="5、RSA">5、RSA</h4><p>使用之前需要安装 rsa 模块</p><pre class="line-numbers language-none"><code class="language-none">pip install rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="应用场景">应用场景</h5><p>在公开密钥加密和电子商业中RSA被广泛使用。</p><p>该算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥，即公钥，而两个大素数组合成私钥。公钥是可发布的供任何人使用，私钥则为自己所有，供解密之用</p><h5 id="非对称加密算法">非对称加密算法</h5><p>1、乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</p><p>2、甲方获取乙方的公钥，然后用它对信息加密。</p><p>3、乙方得到加密后的信息，用私钥解密。</p><h5 id="RSA算法">RSA算法</h5><p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的&quot;非对称加密算法&quot;。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。</p><p>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。</p><h5 id="数学基础">数学基础</h5><p><strong>互质关系</strong></p><p>如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。</p><p>关于互质关系，不难得到以下结论：</p><ol><li><p>任意两个质数构成互质关系，比如13和61。</p></li><li><p>一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。</p></li><li><p>如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。</p></li><li><p>1和任意一个自然数是都是互质关系，比如1和99。</p></li><li><p>p是大于1的整数，则p和p-1构成互质关系，比如57和56。</p></li><li><p>p是大于1的奇数，则p和p-2构成互质关系，比如17和15。</p></li></ol><p><strong>欧拉函数</strong></p><p>请思考以下问题：</p><p>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）</p><p>计算这个值的方法就叫做欧拉函数，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。</p><p>φ(n) 的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。</p><h5 id="密钥生成">密钥生成</h5><p>我们通过一个例子，来理解RSA算法。假设爱丽丝要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？</p><p><img src="https://s2.loli.net/2022/01/25/EqGaUCgbzyJ3xS9.png" alt=""></p><ul><li>第一步，随机选择两个不相等的质数p和q。</li></ul><p>爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）</p><ul><li>第二步，计算p和q的乘积n。</li></ul><p>爱丽丝就把61和53相乘。</p><p>n = 61×53 = 3233</p><p>n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。</p><ul><li>第三步，计算n的欧拉函数φ(n)。</li></ul><p>根据公式：</p><p>φ(n) = (p-1)(q-1)</p><p>爱丽丝算出φ(3233)等于60×52，即3120。</p><ul><li>第四步，随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。</li></ul><p>爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）</p><ul><li>第五步，计算e对于φ(n)的模反元素d。</li></ul><p>所谓&quot;模反元素&quot;就是指有一个整数d，可以使得ed被φ(n)除的余数为1。</p><p>ed ≡ 1 (mod φ(n))</p><p>这个式子等价于</p><p>ed - 1 = kφ(n) (k∈Z)</p><p>于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。</p><p>ex + φ(n)y = 1</p><p>已知 e=17, φ(n)=3120，</p><p>17x + 3120y = 1</p><p>这个方程可以用&quot;扩展欧几里得算法&quot;求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。</p><p>至此所有计算完成。</p><ul><li>第六步，将n和e封装成公钥，n和d封装成私钥。</li></ul><p>在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。</p><ul><li>总结，实际上就是计算n,e,d的过程</li></ul><p>pq的作用用于求n==pq，再用 (p-1)(q-1)求φ(n)，在φ(n)范围内随机选择即为e，d==e对于φ(n)的模反元素</p><h5 id="代码案例">代码案例</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">import rsa  # rsa加密def rsaEncrypt(str):    # 生成公钥、私钥    (pubkey, privkey) &#x3D; rsa.newkeys(512)    print(&quot;pub: &quot;, pubkey)    print(&quot;priv: &quot;, privkey)    # 明文编码格式    content &#x3D; str.encode(&#39;utf-8&#39;)    # 公钥加密    crypto &#x3D; rsa.encrypt(content, pubkey)    return (crypto, privkey)  # rsa解密def rsaDecrypt(str, pk):    # 私钥解密    content &#x3D; rsa.decrypt(str, pk)    con &#x3D; content.decode(&#39;utf-8&#39;)    return con  a, b &#x3D; rsaEncrypt(&quot;hello&quot;)print(&#39;加密后密文：&#39;)print(a)content &#x3D; rsaDecrypt(a, b)print(&#39;解密后明文：&#39;)print(content)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">import rsaimport binascii def rsa_encrypt(rsa_n, rsa_e, message):    key &#x3D; rsa.PublicKey(rsa_n, rsa_e)    message &#x3D; rsa.encrypt(message.encode(), key)    message &#x3D; binascii.b2a_hex(message)    return message.decode()  pubkey_n &#x3D; &#39;8d7e6949d411ce14d7d233d7160f5b2cc753930caba4d5ad24f923a505253b9c39b09a059732250e56c594d735077cfcb0c3508e9f544f101bdf7e97fe1b0d97f273468264b8b24caaa2a90cd9708a417c51cf8ba35444d37c514a0490441a773ccb121034f29748763c6c4f76eb0303559c57071fd89234d140c8bb965f9725&#39;pubkey_e &#x3D; &#39;10001&#39;rsa_n &#x3D; int(pubkey_n, 16)rsa_e &#x3D; int(pubkey_e, 16)message &#x3D; &#39;南北今天很忙&#39;print(&quot;公钥n值长度：&quot;, len(pubkey_n)) aa &#x3D; rsa_encrypt(rsa_n, rsa_e, message)print(aa)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">from Cryptodome.PublicKey import RSAfrom Cryptodome.Cipher import PKCS1_OAEP, PKCS1_v1_5class MyRSA:    def create_rsa_key(self, password):        &quot;&quot;&quot;        创建RSA密钥        步骤说明：        1、从 Crypto.PublicKey 包中导入 RSA，创建一个密码        2、生成 1024&#x2F;2048 位的 RSA 密钥        3、调用 RSA 密钥实例的 exportKey 方法，传入密码、使用的 PKCS 标准以及加密方案这三个参数。        4、将私钥写入磁盘的文件。        5、使用方法链调用 publickey 和 exportKey 方法生成公钥，写入磁盘上的文件。        &quot;&quot;&quot;        key &#x3D; RSA.generate(1024)        encrypted_key &#x3D; key.exportKey(passphrase&#x3D;password.encode(&quot;utf-8&quot;), pkcs&#x3D;8,                                      protection&#x3D;&quot;scryptAndAES128-CBC&quot;)        with open(&quot;my_private_rsa_key.bin&quot;, &quot;wb&quot;) as f:            f.write(encrypted_key)        with open(&quot;my_rsa_public.pem&quot;, &quot;wb&quot;) as f:            f.write(key.publickey().exportKey())    def encrypt(self, plaintext):        # 加载公钥        recipient_key &#x3D; RSA.import_key(            open(&quot;my_rsa_public.pem&quot;).read()        )        cipher_rsa &#x3D; PKCS1_v1_5.new(recipient_key)        en_data &#x3D; cipher_rsa.encrypt(plaintext.encode(&quot;utf-8&quot;))        return en_data        # print(len(en_data), en_data)    def decrypt(self, en_data, password):        # 读取密钥        private_key &#x3D; RSA.import_key(            open(&quot;my_private_rsa_key.bin&quot;).read(),            passphrase&#x3D;password        )        cipher_rsa &#x3D; PKCS1_v1_5.new(private_key)        data &#x3D; cipher_rsa.decrypt(en_data, None)        return data        # print(data)mrsa &#x3D; MyRSA()mrsa.create_rsa_key(&#39;123456&#39;)e &#x3D; mrsa.encrypt(&#39;hello&#39;)d &#x3D; mrsa.decrypt(e, &#39;123456&#39;)print(e)print(d)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="附录：">@附录：</h2><p>非对称加密<br><a href="https://www.bilibili.com/video/BV1Ts411H7u9?from=search&amp;seid=2602407138388579895">https://www.bilibili.com/video/BV1Ts411H7u9?from=search&amp;seid=2602407138388579895</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;我们所说的加密方式，都是对二进制编码的格式进行加密的，对应到Python中，则是我们的&lt;code&gt;Bytes&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所以当我们在Python中进行加密操作的时候，要确保我们操作的是&lt;code&gt;Bytes&lt;/co</summary>
      
    
    
    
    <category term="加密算法" scheme="https://www.alexation.cn/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://www.alexation.cn/tags/Python/"/>
    
    <category term="Javascript" scheme="https://www.alexation.cn/tags/Javascript/"/>
    
    <category term="AES" scheme="https://www.alexation.cn/tags/AES/"/>
    
    <category term="Base64" scheme="https://www.alexation.cn/tags/Base64/"/>
    
    <category term="DES" scheme="https://www.alexation.cn/tags/DES/"/>
    
    <category term="RSA" scheme="https://www.alexation.cn/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>Ajax介绍</title>
    <link href="https://www.alexation.cn/frontend/Ajax/"/>
    <id>https://www.alexation.cn/frontend/Ajax/</id>
    <published>2022-01-25T04:37:09.000Z</published>
    <updated>2022-04-28T09:34:49.786Z</updated>
    
    <content type="html"><![CDATA[<h1>AJAX的学习笔记(Node.js环境)</h1><p>AJAX学习的笔记，主要环境为Node.js</p><p>课程地址： <a href="https://www.bilibili.com/video/BV1WC4y1b78y">https://www.bilibili.com/video/BV1WC4y1b78y</a></p><h2 id="第一章：-原生Ajax">第一章： 原生Ajax</h2><h3 id="1-1-Ajax简介">1.1 Ajax简介</h3><ul><li>Ajax全称为Asynchronous Javascript And XML，即异步JS和XML</li><li>通过Ajax可以在浏览器中向服务器发送异步请求，最大的优势：<strong>无刷新获取数据</strong></li><li>AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式</li></ul><h3 id="1-2-XML简介">1.2 XML简介</h3><ul><li>XML：可扩展标记语言</li><li>XML：被设计用来传输和存储数据</li><li>XML和HTML类似，不同点：HTML中都是预定义标签，XML中没有预定义标签，全是自定义标签，用来表示一些数据</li><li>现在已被JSON取代</li></ul><h3 id="1-3-AJAX-的特点">1.3 AJAX 的特点</h3><h4 id="1-3-1-AJAX的优点">1.3.1 AJAX的优点</h4><ol><li>可以无刷新页面与服务端进行通信</li><li>允许你根据用户事件来更新部分页面内容</li></ol><h4 id="1-3-2-AJAX-的缺点">1.3.2 AJAX 的缺点</h4><ol><li>没有浏览历史，不能回退</li><li>存在跨域问题（同源）</li><li>SEO不友好（爬虫获取不到信息）</li></ol><h3 id="1-4-AJAX-的使用">1.4 AJAX 的使用</h3><h4 id="1-4-1-核心对象">1.4.1 核心对象</h4><h2 id="第二章-jQuery中的AJAX">第二章 jQuery中的AJAX</h2><h3 id="2-1-get请求">2.1 get请求</h3><pre class="line-numbers language-none"><code class="language-none">$.get(url, [data], [callback], [type])url: 请求的URL地址data: 请求携带的参数callbac: 载入成功时回调函数type：设置返回内容格式，xml、html、script、json、text、_default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第三章：-跨域">第三章： 跨域</h2><h3 id="3-1-同源策略">3.1 同源策略</h3><p>同源策略（Same-Origin Policy）最早由 Netscape 公司提出，是浏览器的一种安全策略。</p><p>同源：协议、域名、端口号 必须完全相同</p><p>违背同源策略就是跨域</p><h3 id="3-2-如何解决跨域">3.2 如何解决跨域</h3><h4 id="3-2-1-JSONP">3.2.1 JSONP</h4><ol><li><p>JSONP是什么</p><p>JSONP (JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持get请求</p></li><li><p>JSONP 怎么工作的？</p><p>在网页有一些标签天生具有跨域能力，比如：img, link, iframe, script</p><p>JSONP就是利用<strong>script</strong>标签的跨域能力来发送请求的</p></li><li><p>JSONP的使用</p><ul><li>动态的创建一个script标签</li></ul><pre class="line-numbers language-none"><code class="language-none">var script &#x3D; document.createElement(&quot;script&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>设置script的src，设置回调函数</li></ul><pre class="line-numbers language-none"><code class="language-none">script.src &#x3D; &quot;http:&#x2F;&#x2F;locallhost:3000&#x2F;textAJAX?callback&#x3D;abc&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="3-2-2-CORS">3.2.2 CORS</h3><p>推荐阅读：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></li></ul><ol><li><p>CORS是什么？</p><p>CORS (Cross-Origin Resource Sharing), 跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 等请求。跨域资源共享标准新增了一组 HTTP 首部字段（响应头），允许服务器声明哪些源站通过浏览器有权限访问哪些资源</p></li><li><p>CORS怎么工作的？</p><p>CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。</p></li><li><p>CORS 的使用</p><p>主要是服务端的设置：</p><pre class="line-numbers language-none"><code class="language-none">rounter.get(&quot;&#x2F;testAJAX&quot;,function(req, res)&#123;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;AJAX的学习笔记(Node.js环境)&lt;/h1&gt;
&lt;p&gt;AJAX学习的笔记，主要环境为Node.js&lt;/p&gt;
&lt;p&gt;课程地址： &lt;a href=&quot;https://www.bilibili.com/video/BV1WC4y1b78y&quot;&gt;https://www.bilib</summary>
      
    
    
    
    <category term="前端" scheme="https://www.alexation.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Ajax" scheme="https://www.alexation.cn/tags/Ajax/"/>
    
    <category term="Node.js" scheme="https://www.alexation.cn/tags/Node-js/"/>
    
    <category term="XML" scheme="https://www.alexation.cn/tags/XML/"/>
    
    <category term="跨域" scheme="https://www.alexation.cn/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript基础知识</title>
    <link href="https://www.alexation.cn/javascript/JavaScript-Base/"/>
    <id>https://www.alexation.cn/javascript/JavaScript-Base/</id>
    <published>2022-01-25T00:57:33.000Z</published>
    <updated>2022-01-25T12:20:18.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript">JavaScript</h2><h4 id="JavaScript-是什么">JavaScript 是什么</h4><ul><li><p>JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思）</p></li><li><p>脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行</p></li><li><p>现在也可以基于 Node.js 技术进行服务器端编程</p><p><img src="https://s2.loli.net/2022/01/25/7UFEvY9lauOiqbc.png" alt=""></p></li></ul><h4 id="JS-的组成">JS 的组成</h4><p><img src="https://s2.loli.net/2022/01/25/8i4RHyIjNFV1s2p.png" alt=""></p><ol><li><h4 id="ECMAScript"><strong>ECMAScript</strong></h4><p>ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。</p><p><img src="https://s2.loli.net/2022/01/25/eW7KSO2UdczP6Rp.png" alt=""></p><p>ECMAScript：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</p><p>更多参看MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview">MDN手册</a></p></li><li><h4 id="DOM——文档对象模型"><strong>DOM——文档对象模型</strong></h4><p><strong>文档对象模型</strong>（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）</p></li><li><h4 id="BOM——浏览器对象模型"><strong>BOM——浏览器对象模型</strong></h4><p><strong>浏览器对象模型</strong>(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</p></li></ol><h4 id="JS-初体验">JS 初体验</h4><p>JS 有3种书写位置，分别为行内、内嵌和外部。</p><ol><li><p>行内式</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>点我试试<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick</li><li>注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号</li><li>可读性差， 在html中编写JS大量代码时，不方便阅读；</li><li>引号易错，引号多层嵌套匹配时，非常容易弄混；</li><li>特殊情况下使用</li></ul></li><li><p>内嵌式</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello  World~!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>可以将多行JS代码写到 script 标签中</li><li>内嵌 JS 是学习时常用的方式</li></ul></li><li><p>外部JS文件</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>my.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用</li><li>引用外部 JS文件的 script 标签中间不可以写代码</li><li>适合于JS 代码量比较大的情况</li></ul></li></ol><h2 id="JS基本概念">JS基本概念</h2><h4 id="单行注释">单行注释</h4><p>为了提高代码的可读性，JS与CSS一样，也提供了注释功能。<br>JS中的注释主要有两种，分别是 单行注释 和 多行注释。</p><p>单行注释的注释方式如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 我是一行文字，不想被 JS引擎 执行，所以 注释起来</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 用来注释单行文字（  快捷键   ctrl  +  /   ）</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="多行注释">多行注释</h4><p>多行注释的注释方式如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*  获取用户年龄和姓名  并通过提示框显示出来*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/* 用来注释多行文字 */</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="输入输出语句">输入输出语句</h3><p>为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：</p><table><thead><tr><th>方法</th><th>说明</th><th>归属</th></tr></thead><tbody><tr><td>alert(msg)</td><td>浏览器弹出警示框</td><td>浏览器</td></tr><tr><td>console.log(msg)</td><td>浏览器控制台打印输出信息</td><td>浏览器</td></tr><tr><td>prompt(info)</td><td>浏览器弹出输入框，用户可以输入</td><td>浏览器</td></tr></tbody></table><ul><li>注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。</li></ul><h4 id="声明变量">声明变量</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//  声明变量  </span><span class="token keyword">var</span> age<span class="token punctuation">;</span> <span class="token comment">//  声明一个 名称为age 的变量     </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管</p></li><li><p>age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间</p></li></ul><h4 id="赋值">赋值</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 给 age  这个变量赋值为 10          </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>= 用来把右边的值赋给左边的变量空间中   此处代表赋值的意思</li><li>变量值是程序员保存到变量空间里的值</li></ul><h4 id="变量的初始化">变量的初始化</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> age  <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>  <span class="token comment">// 声明变量同时赋值为 18</span><span class="token comment">// 声明一个变量并赋值， 我们称之为变量的初始化。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="数据类型">数据类型</h3><h4 id="数据类型简介">数据类型简介</h4><ul><li><p>为什么需要数据类型</p><p>在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。</p><p>简单来说，数据类型就是数据的类别型号。比如姓名“张三”，年龄18，这些数据的类型是不一样的。</p></li><li><p>变量的数据类型</p><p>变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment">// 这是一个数字型</span><span class="token keyword">var</span> areYouOk <span class="token operator">=</span> <span class="token string">'是的'</span><span class="token punctuation">;</span>   <span class="token comment">// 这是一个字符串     </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>           <span class="token comment">// x 为数字</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">"Bill"</span><span class="token punctuation">;</span>      <span class="token comment">// x 为字符串    </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>数据类型的分类</p><p>JS 把数据类型分为两类：</p><ul><li><p>简单数据类型 （Number,String,Boolean,Undefined,Null）</p></li><li><p>复杂数据类型 （object)</p></li></ul></li></ul><h4 id="简单数据类型">简单数据类型</h4><p>简单数据类型（基本数据类型）</p><p>JavaScript 中的简单数据类型及其说明如下：</p><p><img src="https://s2.loli.net/2022/01/25/Png7fojKabtkYzB.png" alt=""></p><h5 id="数字型-Number">数字型 Number</h5><p>JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">;</span>       <span class="token comment">// 整数</span><span class="token keyword">var</span> Age <span class="token operator">=</span> <span class="token number">21.3747</span><span class="token punctuation">;</span>  <span class="token comment">// 小数     </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li><p>数字型进制</p><p>最常见的进制有二进制、八进制、十进制、十六进制。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"> <span class="token comment">// 1.八进制数字序列范围：0~7</span><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">07</span><span class="token punctuation">;</span>   <span class="token comment">// 对应十进制的7</span><span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token number">019</span><span class="token punctuation">;</span>  <span class="token comment">// 对应十进制的19</span><span class="token keyword">var</span> num3 <span class="token operator">=</span> <span class="token number">08</span><span class="token punctuation">;</span>   <span class="token comment">// 对应十进制的8</span> <span class="token comment">// 2.十六进制数字序列范围：0~9以及A~F</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">0xA</span><span class="token punctuation">;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加 0x</p></li><li><p>数字型三个特殊值</p><ul><li><p>Infinity ，代表无穷大，大于任何数值</p></li><li><p>-Infinity ，代表无穷小，小于任何数值</p></li><li><p>NaN ，Not a number，代表一个非数值</p></li></ul></li><li><p>isNaN</p><p>用来判断一个变量是否为非数字的类型，返回 true 或者 false</p></li></ol><p><img src="https://s2.loli.net/2022/01/25/MSBmHIqdxtKc1Jw.png" alt=""></p>   <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> usrAge <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">;</span><span class="token keyword">var</span> isOk <span class="token operator">=</span> <span class="token function">isNaN</span><span class="token punctuation">(</span>userAge<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>isNum<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// false ，21 不是一个非数字</span><span class="token keyword">var</span> usrName <span class="token operator">=</span> <span class="token string">"andy"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>userName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true ，"andy"是一个非数字</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="字符串型-String">字符串型 String</h5><p>字符串型可以是引号中的任意文本，其语法为 双引号 “” 和 单引号’’</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> strMsg <span class="token operator">=</span> <span class="token string">"我爱北京天安门~"</span><span class="token punctuation">;</span>  <span class="token comment">// 使用双引号表示字符串</span><span class="token keyword">var</span> strMsg2 <span class="token operator">=</span> <span class="token string">'我爱吃猪蹄~'</span><span class="token punctuation">;</span>    <span class="token comment">// 使用单引号表示字符串</span><span class="token comment">// 常见错误</span><span class="token keyword">var</span> strMsg3 <span class="token operator">=</span> 我爱大肘子<span class="token punctuation">;</span>       <span class="token comment">// 报错，没使用引号，会被认为是js代码，但js没有这些语法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。</p><ol><li><p>字符串引号嵌套</p><p>JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双)</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> strMsg <span class="token operator">=</span> <span class="token string">'我是"高帅富"程序猿'</span><span class="token punctuation">;</span>   <span class="token comment">// 可以用''包含""</span><span class="token keyword">var</span> strMsg2 <span class="token operator">=</span> <span class="token string">"我是'高帅富'程序猿"</span><span class="token punctuation">;</span>  <span class="token comment">// 也可以用"" 包含''</span><span class="token comment">//  常见错误</span><span class="token keyword">var</span> badQuotes <span class="token operator">=</span> 'What on earth<span class="token operator">?</span>"<span class="token punctuation">;</span> <span class="token comment">// 报错，不能 单双引号搭配</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>转义符</th><th>解释说明</th></tr></thead><tbody><tr><td>\n</td><td>换行符，n   是   newline   的意思</td></tr><tr><td>\ \</td><td>斜杠   \</td></tr><tr><td>’</td><td>’   单引号</td></tr><tr><td>&quot;</td><td>”双引号</td></tr><tr><td>\t</td><td>tab  缩进</td></tr><tr><td>\b</td><td>空格 ，b   是   blank  的意思</td></tr></tbody></table></li><li><p>字符串长度（与Python不一样）</p><p>​字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> strMsg <span class="token operator">=</span> <span class="token string">"我是帅气多金的程序猿！"</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>strMsg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 显示 11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>字符串拼接</p><ul><li><p>多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串</p></li><li><p>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//1.1 字符串 "相加"</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'hello'</span> <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello world</span><span class="token comment">//1.2 数值字符串 "相加"</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'100'</span> <span class="token operator">+</span> <span class="token string">'100'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100100</span><span class="token comment">//1.3 数值字符串 + 数值</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'11'</span> <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 1112 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><em><strong>+ 号总结口诀：数值相加 ，字符相连</strong></em></p></li></ul></li><li><p>字符串拼接加强</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Alexation'</span> <span class="token operator">+</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 只要有字符就会相连 </span><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Alexation age 岁啦'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 这样不行哦</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Alexation'</span> <span class="token operator">+</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// Alexation 18</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Alexation'</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token string">'岁啦'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Alexation 18岁啦</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>经常会将字符串和变量来拼接，变量可以很方便地修改里面的值</li><li>变量是不能添加引号的，因为加引号的变量会变成字符串</li><li>如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间</li></ul></li></ol><h5 id="布尔型Boolean">布尔型Boolean</h5><p>布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。</p><p>布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">false</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="Undefined和-Null">Undefined和 Null</h5><p>一个声明后没有被赋值的变量会有一个默认值undefined ( 如果进行相连或者相加时，注意结果）</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> variable<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'你好'</span> <span class="token operator">+</span> variable<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 你好undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">11</span> <span class="token operator">+</span> variable<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// NaN</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">+</span> variable<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//  NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null)</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> vari <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'你好'</span> <span class="token operator">+</span> vari<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 你好null</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">11</span> <span class="token operator">+</span> vari<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 11</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">+</span> vari<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//  1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="获取变量数据类型">获取变量数据类型</h4><p>typeof 可用来获取检测变量的数据类型</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> num<span class="token punctuation">)</span> <span class="token comment">// 结果 number      </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不同类型的返回值</p><p><img src="https://s2.loli.net/2022/01/25/Y4lS7UNWBmHaJFI.png" alt=""></p><h4 id="数据类型转换">数据类型转换</h4><p>​什么是数据类型转换？</p><p>​使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另一种数据类型，通常会实现3种方式的转换：</p><ul><li>转换为字符串类型</li><li>转换为数字型</li><li>转换为布尔型</li></ul><h5 id="转换为字符串">转换为字符串</h5><p><img src="https://s2.loli.net/2022/01/25/cd6ru7M9xmBXHLN.png" alt=""></p><ul><li><p>toString() 和 String()  使用方式不一样。</p></li><li><p>三种转换方式，更多第三种加号拼接字符串转换方式， 这一种方式也称之为隐式转换。</p></li><li><p>转换为数字型（重点）</p><p><img src="https://s2.loli.net/2022/01/25/5FoIemtAvELnOMX.png" alt=""></p><ul><li>注意 parseInt 和 parseFloat 单词的大小写，这2个是重点</li><li>隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型</li></ul></li></ul><h5 id="转换为布尔型">转换为布尔型</h5><p><img src="https://s2.loli.net/2022/01/25/1VZIid5HDmS7On6.png" alt=""></p><ul><li><p>代表空、否定的值会被转换为 false  ，如 ‘’、0、NaN、null、undefined</p></li><li><p>其余值都会被转换为 true</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">'小白'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="关键字和保留字">关键字和保留字</h3><h4 id="标识符">标识符</h4><p>标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字。</p><p>标识符不能是关键字或保留字。</p><h4 id="关键字">关键字</h4><p>关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名。</p><p>包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。</p><h4 id="保留字">保留字</h4><p>保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。</p><p>包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。</p><p>注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。</p><h2 id="程序的逻辑">程序的逻辑</h2><h3 id="运算符（操作符）">运算符（操作符）</h3><h4 id="递增和递减运算符">递增和递减运算符</h4><p>递增和递减运算符概述</p><p>如果需要反复给数字变量添加或减去1，可以使用递增（++）和递减（ – ）运算符来完成。</p><p>在 JavaScript 中，递增（++）和递减（ – ）既可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。</p><p>注意：递增和递减运算符必须和变量配合使用。</p><p><strong>递增运算符</strong></p><ul><li><p>前置递增运算符</p><p>++num 前置递增，就是自加1，类似于 num =  num + 1，但是 ++num 写起来更简单。</p><p>使用口诀：先自加，后返回值</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span>  num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token operator">++</span>num <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 21</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>后置递增运算符</p><p>num++ 后置递增，就是自加1，类似于 num =  num + 1 ，但是 num++ 写起来更简单。</p><p>使用口诀：先返回原值，后自加</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span>  num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">+</span> num<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="比较运算符">比较运算符</h4><p>比较运算符概述</p><p>概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果。</p><p><img src="https://s2.loli.net/2022/01/25/rIMtDjcCL6TdPky.png" alt=""></p><p>等号比较</p><p><img src="https://s2.loli.net/2022/01/25/5Qg3mhzOZkwTDnv.png" alt=""></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">18</span> <span class="token operator">==</span> <span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">18</span> <span class="token operator">===</span> <span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="逻辑运算符">逻辑运算符</h4><p>逻辑运算符概述</p><p>概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断</p><p><img src="D:/Hexo/source/_posts/javascript/assets/%25E5%259B%25BE%25E7%2589%25874-1594236524538.png" alt=""></p><ul><li><p>逻辑与&amp;&amp;</p><p>两边都是 true才返回 true，否则返回 false</p></li><li><p>逻辑或 ||</p><p>两边都是 true才返回 true，否则返回 false</p></li><li><p>逻辑非 ！</p><p>逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> isOk <span class="token operator">=</span> <span class="token operator">!</span><span class="token boolean">true</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>isOk<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>短路运算（逻辑中断）</p><p>短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值;</p><ul><li><p>逻辑与</p><p>语法： 表达式1 &amp;&amp; 表达式2</p><ul><li>如果第一个表达式的值为真，则返回表达式2</li><li>如果第一个表达式的值为假，则返回表达式1</li></ul></li></ul></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">123</span> <span class="token operator">&amp;&amp;</span> <span class="token number">456</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 456</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token number">456</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 0</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">123</span> <span class="token operator">&amp;&amp;</span> <span class="token number">456</span><span class="token operator">&amp;&amp;</span> <span class="token number">789</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 789</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>逻辑或</p><p>语法： 表达式1 || 表达式2</p><p>如果第一个表达式的值为真，则返回表达式1</p><p>如果第一个表达式的值为假，则返回表达式2</p> <pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">123</span> <span class="token operator">||</span> <span class="token number">456</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//  123</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token operator">||</span>  <span class="token number">456</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//  456</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">123</span> <span class="token operator">||</span> <span class="token number">456</span> <span class="token operator">||</span> <span class="token number">789</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//  123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="运算符优先级">运算符优先级</h4><p><img src="https://s2.loli.net/2022/01/25/TXZCOmI4KJiSvqj.png" alt=""></p><ul><li>一元运算符里面的逻辑非优先级很高</li><li>逻辑与比逻辑或优先级高</li></ul><h3 id="流程控制">流程控制</h3><h4 id="分支流程控制">分支流程控制</h4><ul><li><p>分支结构</p><p>由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果.</p><p>JS 语言提供了两种分支结构语句：if 语句、switch 语句</p></li><li><p>if 语句</p><ul><li>语法结构</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 条件成立执行代码，否则什么也不做</span><span class="token keyword">if</span> <span class="token punctuation">(</span>条件表达式<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 条件成立执行的代码语句</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>语句可以理解为一个行为，循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，一般情况下，会分割成一个一个的语句。</p><ul><li><p>执行流程</p><p><img src="https://s2.loli.net/2022/01/25/LY6Scb74rkGaMA1.png" alt=""></p></li><li><p>if else语句（双分支语句）</p><ul><li><p>语法结构</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 条件成立  执行 if 里面代码，否则执行else 里面的代码</span><span class="token keyword">if</span> <span class="token punctuation">(</span>条件表达式<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// [如果] 条件成立执行的代码</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// [否则] 执行的代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行流程</p><p><img src="https://s2.loli.net/2022/01/25/sg1MBUdGKecSvH4.png" alt=""></p></li></ul></li><li><p>if else if 语句(多分支语句)</p><ul><li><p>语法结构</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 适合于检查多重条件。</span><span class="token keyword">if</span> <span class="token punctuation">(</span>条件表达式<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    语句<span class="token number">1</span>；<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>条件表达式<span class="token number">2</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    语句<span class="token number">2</span>；<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>条件表达式<span class="token number">3</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>   语句<span class="token number">3</span>； <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 上述条件都不成立执行此处代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行逻辑</p></li></ul><p><img src="https://s2.loli.net/2022/01/25/o94BpbOwCua7Dik.png" alt=""></p></li></ul><h4 id="三元表达式">三元表达式</h4><ul><li><p>语法结构</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">表达式<span class="token number">1</span> <span class="token operator">?</span> 表达式<span class="token number">2</span> <span class="token operator">:</span> 表达式<span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行思路</p><ul><li>如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值</li><li>简单理解： 就类似于  if  else （双分支） 的简写</li></ul></li></ul><h4 id="switch分支流程控制">switch分支流程控制</h4><ul><li><p>语法结构</p><p>switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用 switch。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">switch</span><span class="token punctuation">(</span> 表达式 <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token keyword">case</span> value1<span class="token operator">:</span>        <span class="token comment">// 表达式 等于 value1 时要执行的代码</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> value2<span class="token operator">:</span>        <span class="token comment">// 表达式 等于 value2 时要执行的代码</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token comment">// 表达式 不等于任何一个 value 时要执行的代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>switch ：开关 转换  ， case ：小例子   选项</p></li><li><p>关键字 switch 后面括号内可以是表达式或值， 通常是一个变量</p></li><li><p>关键字 case , 后跟一个选项的表达式或值，后面跟一个冒号</p></li><li><p>switch 表达式的值会与结构中的 case 的值做比较</p></li><li><p>如果存在匹配全等(===) ，则与该 case 关联的代码块会被执行，并在遇到 break 时停止，整个 switch 语句代码执行结束</p></li><li><p>如果所有的 case 的值都和表达式的值不匹配，则执行 default 里的代码</p><p><strong>注意： 执行case 里面的语句时，如果没有break，则继续执行下一个case里面的语句。</strong></p></li></ul><h3 id="循环">循环</h3><h4 id="for循环">for循环</h4><p>语法结构</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span>初始化变量<span class="token punctuation">;</span> 条件表达式<span class="token punctuation">;</span> 操作表达式 <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//循环体</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>初始化变量</td><td>通常被用于初始化一个计数器，该表达式可以使用 var 关键字声明新的变量，这个变量帮我们来记录次数。</td></tr><tr><td>条件表达式</td><td>用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环。</td></tr><tr><td>操作表达式</td><td>用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环。</td></tr></tbody></table><p><strong>执行过程：</strong></p><ol><li>初始化变量，初始化操作在整个 for 循环只会执行一次。</li></ol><ul><li>执行条件表达式，如果为true，则执行循环体语句，否则退出循环，循环结束。</li></ul><ol><li>执行操作表达式，此时第一轮结束。</li><li>第二轮开始，直接去执行条件表达式（不再初始化变量），如果为 true ，则去执行循环体语句，否则退出循环。</li><li>继续执行操作表达式，第二轮结束。</li><li>后续跟第二轮一致，直至条件表达式为假，结束整个 for 循环。</li></ol><p><strong>断点调试：</strong></p><p>断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。断点调试可以帮助观察程序的运行过程</p><p>断点调试的流程：<br>1、浏览器中按 F12–&gt; sources --&gt;找到需要调试的文件–&gt;在程序的某一行设置断点<br>2、Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。<br>3、摁下F11，程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。</p><ul><li><p>for 循环重复不相同的代码</p><p>例如，求输出1到100岁：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//  基本写法</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这个人今年'</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">'岁了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>例如，求输出1到100岁，并提示出生、死亡</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// for 里面是可以添加其他语句的 </span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这个人今年1岁了， 它出生了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这个人今年100岁了，它死了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这个人今年'</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">'岁了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>for循环因为有了计数器的存在，还可以重复的执行某些操作，比如做一些算术运算。</p></li></ul><h4 id="while循环">while循环</h4><p>while语句的语法结构如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">while</span> <span class="token punctuation">(</span>条件表达式<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 循环体代码 </span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行思路：</p><ul><li>1 先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码</li><li>2 执行循环体代码</li><li>3 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束</li></ul><p>注意：</p><ul><li>使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环</li></ul><h4 id="do-while循环">do-while循环</h4><p>do… while 语句的语法结构如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">do</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 循环体代码 - 条件表达式为 true 时重复执行循环体代码</span><span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>条件表达式<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行思路</p><ul><li><p>1 先执行一次循环体代码</p></li><li><p>2 再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面代码</p><p>注意：先再执行循环体，再判断，do…while循环语句至少会执行一次循环体代码</p></li></ul><h4 id="continue、break">continue、break</h4><p>与python一致</p><h3 id="数组">数组</h3><h4 id="数组的概念">数组的概念</h4><ul><li>数组可以把一组相关的数据一起存放，并提供方便的访问(获取）方式。</li><li>数组是指<strong>一组数据的集合</strong>，其中的每个数据被称作<strong>元素</strong>，在数组中可以<strong>存放任意类型的元素</strong>。数组是一种将一组数据存储在单个变量名下的优雅方式。</li></ul><h4 id="创建数组">创建数组</h4><p>JS 中创建数组有两种方式：</p><ul><li><p>利用  new 创建数组</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> 数组名 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ；<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 创建一个新的空数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>注意 Array () ，A 要大写</p><ul><li><p>利用数组字面量创建数组</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//1. 使用数组字面量方式创建空的数组</span><span class="token keyword">var</span>  数组名 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>；<span class="token comment">//2. 使用数组字面量方式创建带初始值的数组</span><span class="token keyword">var</span>  数组名 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'小白'</span><span class="token punctuation">,</span><span class="token string">'小黑'</span><span class="token punctuation">,</span><span class="token string">'大黄'</span><span class="token punctuation">,</span><span class="token string">'瑞奇'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>数组的字面量是方括号 [ ]</p><ul><li>声明数组并赋值称为数组的初始化</li><li>这种字面量方式也是我们以后最多使用的方式</li></ul></li><li><p>数组元素的类型</p><p>数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arrStus <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'小白'</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token number">28.9</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="获取数组中的元素">获取数组中的元素</h4><p>索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。</p><p><img src="https://s2.loli.net/2022/01/25/xW9tA7iFJEzvlZK.png" alt=""></p><p>数组可以通过索引来访问、设置、修改对应的数组元素，可以通过“数组名[索引]”的形式来获取数组中的元素。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 定义数组</span><span class="token keyword">var</span> arrStus <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 获取数组中的第2个元素</span><span class="token function">alert</span><span class="token punctuation">(</span>arrStus<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined</p><h4 id="遍历数组">遍历数组</h4><ul><li><p>数组遍历</p><p>把数组中的每个元素从头到尾都访问一次（类似学生的点名），可以通过 for 循环索引遍历数组中的每一项</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span><span class="token string">'green'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arrStus<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>数组的长度</p><p>数组的长度：默认情况下表示数组中元素的个数</p><p>使用“数组名.length”可以访问数组元素的数量（数组长度）。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arrStus <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>arrStus<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p></li><li><p>此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。</p></li><li><p>当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化</p><ul><li>数组的length属性可以被修改：</li></ul></li><li><p>如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素；</p><ul><li>如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除</li></ul></li></ul><h4 id="数组中新增元素">数组中新增元素</h4><p>数组中可以通过以下方式在数组的末尾插入新元素：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">数组<span class="token punctuation">[</span> 数组<span class="token punctuation">.</span>length <span class="token punctuation">]</span> <span class="token operator">=</span> 新数据<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="函数">函数</h3><h4 id="函数的概念">函数的概念</h4><p>在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。</p><p>函数：就是<strong>封装了一段可被重复调用执行的代码块</strong>。通过此代码块可以<strong>实现大量代码的重复使用</strong>。</p><h4 id="函数的使用">函数的使用</h4><h5 id="声明函数">声明函数</h5><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 声明函数</span><span class="token keyword">function</span> <span class="token function">函数名</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//函数体代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>function 是声明函数的关键字,必须小写</p></li><li><p>由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum</p></li></ul><h5 id="调用函数">调用函数</h5><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 调用函数</span><span class="token function">函数名</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 通过调用函数名来执行函数体代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>调用的时候千万不要忘记添加小括号</p></li><li><p>口诀：函数不调用，自己不执行</p><p>注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。</p></li></ul><p>例子：封装计算1-100累加和</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*    计算1-100之间值的函数*/</span><span class="token comment">// 声明函数</span><span class="token keyword">function</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> sumNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 准备一个变量，保存数字和</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sumNum <span class="token operator">+=</span> i<span class="token punctuation">;</span><span class="token comment">// 把每个数值 都累加 到变量中</span>  <span class="token punctuation">&#125;</span>  <span class="token function">alert</span><span class="token punctuation">(</span>sumNum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 调用函数</span><span class="token function">getSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="函数的参数">函数的参数</h4><h5 id="函数参数语法">函数参数语法</h5><ul><li><p>形参：函数定义时设置接收调用时传入</p></li><li><p>实参：函数调用时传入小括号内的真实数据</p><p><img src="https://s2.loli.net/2022/01/25/8EAVZwUidC3cjgN.png" alt=""></p><p>参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。</p><p>函数参数的运用：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 带参数的函数声明</span><span class="token keyword">function</span> <span class="token function">函数名</span><span class="token punctuation">(</span><span class="token parameter">形参<span class="token number">1</span><span class="token punctuation">,</span> 形参<span class="token number">2</span> <span class="token punctuation">,</span> 形参<span class="token number">3.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 可以定义任意多的参数，用逗号分隔</span>  <span class="token comment">// 函数体</span><span class="token punctuation">&#125;</span><span class="token comment">// 带参数的函数调用</span><span class="token function">函数名</span><span class="token punctuation">(</span>实参<span class="token number">1</span><span class="token punctuation">,</span> 实参<span class="token number">2</span><span class="token punctuation">,</span> 实参<span class="token number">3.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>调用的时候实参值是传递给形参的</li><li>形参简单理解为：不用声明的变量</li><li>实参和形参的多个参数之间用逗号（,）分隔</li></ol></li></ul><h5 id="函数形参和实参数量不匹配时">函数形参和实参数量不匹配时</h5><p><img src="https://s2.loli.net/2022/01/25/qeJQoI5WSLu9PBm.png" alt=""></p><p>注意：在JavaScript中，形参的默认值是undefined。</p><p>小结：</p><ul><li>函数可以带参数也可以不带参数</li><li>声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined</li><li>调用函数的时候，函数名括号里面的是实参</li><li>多个参数中间用逗号分隔</li><li>形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配</li></ul><h4 id="函数的返回值">函数的返回值</h4><h5 id="return-语句">return 语句</h5><p>返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 声明函数</span><span class="token keyword">function</span> 函数名（）<span class="token punctuation">&#123;</span>    <span class="token operator">...</span>    <span class="token keyword">return</span>  需要返回的值；<span class="token punctuation">&#125;</span><span class="token comment">// 调用函数</span><span class="token function">函数名</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 此时调用函数就可以得到函数体内return 后面的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在使用 return 语句时，函数会停止执行，并返回指定的值</li><li>如果函数没有 return ，返回的值是 undefined</li></ul><h5 id="break-continue-return-的区别">break ,continue ,return 的区别</h5><ul><li>break ：结束当前的循环体（如 for、while）</li><li>continue ：跳出本次循环，继续执行下次循环（如 for、while）</li><li>return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码</li></ul><h4 id="arguments的使用">arguments的使用</h4><p>当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p><ul><li><p>具有 length 属性</p></li><li><p>按索引方式储存数据</p></li><li><p>不具有数组的 push , pop 等方法</p><p>注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</p></li></ul><h4 id="函数案例">函数案例</h4><p>​函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。</p><h4 id="函数的两种声明方式">函数的两种声明方式</h4><ul><li><p>自定义函数方式(命名函数)</p><p>利用函数关键字 function 自定义函数方式</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 声明定义方式</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token comment">// 调用  </span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>因为有名字，所以也被称为命名函数</li><li>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</li></ul></li><li><p>函数表达式方式(匿名函数）</p><p>利用函数表达式方式的写法如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 这是函数表达式写法，匿名函数后面跟分号结束</span><span class="token keyword">var</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span>；<span class="token comment">// 调用的方式，函数调用必须写到函数体下面</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>因为函数没有名字，所以也被称为匿名函数</li><li>这个fn 里面存储的是一个函数</li><li>函数表达式方式原理跟声明变量方式是一致的</li><li>函数调用的代码必须写到函数体后面</li></ul></li></ul><h2 id="作用域">作用域</h2><h4 id="JS没有块级作用域">JS没有块级作用域</h4><ul><li><p>块作用域由 { } 包括。</p></li><li><p>在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码：</p><p>python 有块级作用域：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">if True:    num &#x3D; 123    print(num)  # 123print(num)  # 报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上java代码会报错，是因为代码中 { } 即一块作用域，其中声明的变量 num，在 “{ }” 之外不能使用；</p><p>而与之类似的JavaScript代码，则不会报错：</p><p>Js中没有块级作用域（在ES6之前）</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//123</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="对象">对象</h3><h4 id="创建对象的三种方式">创建对象的三种方式</h4><h5 id="使用对象字面量创建对象："><strong>使用对象字面量创建对象</strong>：</h5><p>就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法；{ } 里面采取键值对的形式表示</p><ul><li><p>键：相当于属性名</p></li><li><p>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）</p><p>代码如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> star <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    name <span class="token operator">:</span> <span class="token string">'Asuna'</span><span class="token punctuation">,</span>    age <span class="token operator">:</span> <span class="token number">15</span><span class="token punctuation">,</span>    sex <span class="token operator">:</span> <span class="token string">'女'</span><span class="token punctuation">,</span>    <span class="token function-variable function">sayHi</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'大家好啊~'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中 star即是创建的对象。</p></li></ul><h5 id="对象的使用">对象的使用</h5><ul><li><p>对象的属性</p><ul><li>对象中存储<strong>具体数据</strong>的 &quot;键值对&quot;中的 &quot;键&quot;称为对象的属性，即对象中存储具体数据的项</li></ul></li><li><p>对象的方法</p><ul><li>对象中存储<strong>函数</strong>的 &quot;键值对&quot;中的 &quot;键&quot;称为对象的方法，即对象中存储函数的项</li></ul></li><li><p>访问对象的属性</p><ul><li><p>对象里面的属性调用 : 对象.属性名 ，这个小点 . 就理解为“ 的 ”</p></li><li><p>对象里面属性的另一种调用方式 : 对象[‘属性名’]，注意方括号里面的属性必须加引号</p><p>示例代码如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>star<span class="token punctuation">.</span>name<span class="token punctuation">)</span>     <span class="token comment">// 调用名字属性</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>star<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// 调用名字属性</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p>调用对象的方法</p><ul><li><p>对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号</p><p>示例代码如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">star<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 调用 sayHi 方法,注意，一定不要忘记带后面的括号</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>变量、属性、函数、方法总结</p><p>属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器</p><ul><li>变量：单独声明赋值，单独存在</li><li>属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征</li></ul></li></ul><ul><li>方法是对象的一部分，函数不是对象的一部分，函数是单独封装操作的容器<ul><li>函数：单独存在的，通过“函数名()”的方式就可以调用</li><li>方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能。</li></ul></li></ul><h5 id="利用-new-Object-创建对象">利用 new Object 创建对象</h5><ul><li><p>创建空对象</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> andy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象</p></li><li><p>给空对象添加属性和方法</p><ul><li><p>通过对象操作属性和方法的方式，来为对象增加属性和方法</p><p>示例代码如下：</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">andy<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Asuna'</span><span class="token punctuation">;</span>andy<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>andy<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'女'</span><span class="token punctuation">;</span>andy<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'大家好啊~'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li>Object() ：第一个字母大写</li><li>new Object() ：需要 new 关键字</li><li>使用的格式：对象.属性 =  值;</li></ul></li></ul><h5 id="利用构造函数创建对象">利用构造函数创建对象</h5><p><strong>构造函数</strong></p><ul><li><p>构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p></li><li><p>构造函数的封装格式：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">构造函数名</span><span class="token punctuation">(</span><span class="token parameter">形参<span class="token number">1</span><span class="token punctuation">,</span>形参<span class="token number">2</span><span class="token punctuation">,</span>形参<span class="token number">3</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>属性名<span class="token number">1</span> <span class="token operator">=</span> 参数<span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>属性名<span class="token number">2</span> <span class="token operator">=</span> 参数<span class="token number">2</span><span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>属性名<span class="token number">3</span> <span class="token operator">=</span> 参数<span class="token number">3</span><span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>方法名 <span class="token operator">=</span> 函数体<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>构造函数的调用格式</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">构造函数名</span><span class="token punctuation">(</span>实参<span class="token number">1</span>，实参<span class="token number">2</span>，实参<span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上代码中，obj即接收到构造函数创建出来的对象。</p></li><li><p>注意事项</p><ol><li>构造函数约定<strong>首字母大写</strong>。</li><li>函数内的属性和方法前面需要添加 <strong>this</strong> ，表示当前对象的属性和方法。</li><li>构造函数中<strong>不需要 return 返回结果</strong>。</li><li>当我们创建对象的时候，<strong>必须用 new 来调用构造函数</strong>。</li></ol></li><li><p>其他</p><p>构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）<br>创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化</p></li></ul><h4 id="new关键字的作用">new关键字的作用</h4><ol><li>在构造函数代码开始执行之前，创建一个空对象；</li><li>修改this的指向，把this指向创建出来的空对象；</li><li>执行函数的代码</li><li>在函数完成之后，返回this—即创建出来的对象</li></ol><h4 id="遍历对象">遍历对象</h4><p>for… in 语句用于对数组或者对象的属性进行循环操作。</p><p>其语法如下：</p>  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span>变量 <span class="token keyword">in</span> 对象名字<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 在此执行代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。</p>  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 这里的 k 是属性名</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里的 obj[k] 是属性值</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内置对象">内置对象</h2><h3 id="内置对象-2">内置对象</h3><h4 id="内置对象-3">内置对象</h4><p>JavaScript 中的对象分为3种：<strong>自定义对象 、内置对象、 浏览器对象</strong><br>前面两种对象是JS 基础 内容，属于 ECMAScript；  第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是<strong>最基本而必要的功能</strong>（属性和方法），内置对象最大的优点就是帮助我们快速开发</p><p>JavaScript 提供了多个内置对象：Math、 Date 、Array、String等</p><h4 id="查文档">查文档</h4><p>查找文档：学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN/W3C来查询。<br>Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。<br>MDN:<a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><h4 id="Math对象">Math对象</h4><p>Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。</p><table><thead><tr><th>属性、方法名</th><th>功能</th></tr></thead><tbody><tr><td>Math.PI</td><td>圆周率</td></tr><tr><td>Math.floor()</td><td>向下取整</td></tr><tr><td>Math.ceil()</td><td>向上取整</td></tr><tr><td>Math.round()</td><td>四舍五入版 就近取整   注意 -3.5   结果是  -3</td></tr><tr><td>Math.abs()</td><td>绝对值</td></tr><tr><td>Math.max()/Math.min()</td><td>求最大和最小值</td></tr><tr><td>Math.random()</td><td>获取范围在[0,1)内的随机值</td></tr></tbody></table><p>注意：上面的方法使用时必须带括号</p><p><strong>获取指定范围内的随机整数</strong>：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token parameter">min<span class="token punctuation">,</span> max</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="日期对象">日期对象</h4><p>Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间</p><ul><li><p>使用Date实例化日期对象</p><ul><li>获取当前时间必须实例化：</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>获取指定时间的日期对象</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> future <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">'2019/5/1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象</p></li><li><p>使用Date实例的方法和属性</p><p><img src="https://s2.loli.net/2022/01/25/4i2l3gOeSNCZt7d.png" alt=""></p></li><li><p>通过Date实例获取总毫米数</p><ul><li><p>总毫秒数的含义</p><p>​基于1970年1月1日（世界标准时间）起的毫秒数</p></li><li><p>获取总毫秒数</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 实例化Date对象</span><span class="token keyword">var</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1. 用于获取对象的原始值</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>date<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>date<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 2. 简单写可以这么做</span><span class="token keyword">var</span> now <span class="token operator">=</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3. HTML5中提供的方法，有兼容性问题</span><span class="token keyword">var</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="数组对象">数组对象</h4><h5 id="添加删除数组元素的方法">添加删除数组元素的方法</h5><ul><li><p>数组中有进行增加、删除元素的方法，部分方法如下表</p><p><img src="https://s2.loli.net/2022/01/25/cbp4GCLmfTuHF6D.png" alt=""></p><p>注意：push、unshift为增加元素方法；pop、shift为删除元素的方法</p></li></ul><h5 id="数组转换为字符串">数组转换为字符串</h5><ul><li><p>数组中有把数组转化为字符串的方法，部分方法如下表</p><p><img src="https://s2.loli.net/2022/01/25/ALomgf9Z6I7BdJ8.png" alt=""></p><p>注意：join方法如果不传入参数，则按照 “ , ”拼接元素</p></li></ul><h5 id="其他方法">其他方法</h5><ul><li><p>数组中还有其他操作方法，同学们可以在课下自行查阅学习</p><p><img src="https://s2.loli.net/2022/01/25/LXl6EdIye1nTCN7.png" alt=""></p></li></ul><h4 id="字符串对象">字符串对象</h4><h5 id="基本包装类型">基本包装类型</h5><p>为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。</p><p>基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 下面代码有什么问题？</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'andy'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为</p><p>js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 1. 生成临时变量，把简单类型包装为复杂数据类型</span><span class="token keyword">var</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'andy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2. 赋值给我们声明的字符变量</span>str <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment">// 3. 销毁临时变量</span>temp <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="字符串的不可变">字符串的不可变</h5><p>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</p><p>当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。<br>由于字符串的不可变，在<strong>大量拼接字符串</strong>的时候会有效率问题</p><h5 id="根据字符返回位置">根据字符返回位置</h5><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法：</p><p><img src="https://s2.loli.net/2022/01/25/gn4Map1d6uKANxC.png" alt=""></p><p>​案例：查找字符串&quot;abcoefoxyozzopp&quot;中所有o出现的位置以及次数</p><ol><li>先查找第一个o出现的位置</li><li>然后 只要indexOf 返回的结果不是 -1 就继续往后查找</li><li>因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找</li></ol><h5 id="根据位置返回字符">根据位置返回字符</h5><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：</p><p><img src="https://s2.loli.net/2022/01/25/1axHvLDEiOWJydp.png" alt=""></p><p>在上述方法中，charCodeAt方法返回的是指定位置上字符对应的ASCII码。</p><p>案例：判断一个字符串 ‘abcoefoxyozzopp’ 中出现次数最多的字符，并统计其次数</p><ol><li><p>核心算法：利用 charAt(） 遍历这个字符串</p></li><li><p>把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1</p></li><li><p>遍历对象，得到最大值和该字符</p><p>注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象总，对应的属性值是该字符出现的次数</p></li></ol><h5 id="字符串操作方法">字符串操作方法</h5><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：</p><p><img src="https://s2.loli.net/2022/01/25/QOXq1nTB4AUuL7d.png" alt=""></p><h5 id="replace-方法">replace()方法</h5><p>replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">字符串<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>被替换的字符串， 要替换为的字符串<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="split-方法">split()方法</h5><p>​split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。</p><p>​其使用格式如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">字符串<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"分割字符"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="jQuery">jQuery</h2><h3 id="JavaScript-库">JavaScript 库</h3><p>​JavaScript库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。</p><blockquote><p>简单理解： 就是一个JS 文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。</p><p>比如 jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。</p></blockquote><p>​常见的JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等，这些库都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的，我们主要学习的是 jQuery。</p><h3 id="jQuery的概念">jQuery的概念</h3><p>​jQuery总体概况如下 :</p><ul><li><p>jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。</p></li><li><p>j 就是 JavaScript；   Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。</p></li><li><p>jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。</p></li><li><p>学习jQuery本质： 就是学习调用这些函数（方法）。</p></li><li><p>jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。</p><p><img src="https://s2.loli.net/2022/01/25/rMR6s7VpnSa4DtF.png" alt="jQuery概述"></p></li></ul><h3 id="体验jQuery">体验jQuery</h3><p>​步骤：</p><ul><li>引入jQuery文件。</li><li>在文档最末尾插入 script 标签，书写体验代码。</li><li>$(‘div’).hide() 可以隐藏盒子。</li></ul><h3 id="jQuery的入口函数">jQuery的入口函数</h3><p>​jQuery中常见的两种入口函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 第一种: 简单易用。</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token operator">...</span>  <span class="token comment">// 此处是页面 DOM 加载完成的入口</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// 第二种: 繁琐，但是也可以实现</span><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token operator">...</span>  <span class="token comment">//  此处是页面DOM加载完成的入口</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​总结：</p><ol><li>等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装。</li><li>相当于原生 js 中的 DOMContentLoaded。</li><li>不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css文件、图片加载完毕才执行内部代码。</li><li>更推荐使用第一种方式。</li></ol><h3 id="jQuery中的顶级对象">jQuery中的顶级对象$</h3><ol><li>$是 jQuery 的别称，在代码中可以使用 jQuery 代替，但一般为了方便，通常都直接使用 $ 。</li><li>$是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成jQuery对象，就可以调用jQuery 的方法。</li></ol><h3 id="jQuery-对象和-DOM-对象">jQuery 对象和 DOM 对象</h3><p>​使用 jQuery 方法和原生JS获取的元素是不一样的，总结如下 :</p><ol><li>用原生 JS 获取来的对象就是 DOM 对象</li><li>jQuery 方法获取的元素就是 jQuery 对象。</li><li>jQuery 对象本质是： 利用$对DOM 对象包装后产生的对象（伪数组形式存储）。</li></ol><blockquote><p>注意：</p><p>只有 jQuery 对象才能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 方法。</p></blockquote><p><img src="https://s2.loli.net/2022/01/25/BGZSpImjyKvr51A.png" alt="jQuery对象和DOM对象"></p><h3 id="jQuery-对象和-DOM-对象转换">jQuery 对象和 DOM 对象转换</h3><p>​DOM 对象与 jQuery 对象之间是可以相互转换的。因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 1.DOM对象转换成jQuery对象，方法只有一种</span><span class="token keyword">var</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'box'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取DOM对象</span><span class="token keyword">var</span> jQueryObject <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>box<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 把DOM对象转换为 jQuery 对象</span><span class="token comment">// 2.jQuery 对象转换为 DOM 对象有两种方法：</span><span class="token comment">//   2.1 jQuery对象[索引值]</span><span class="token keyword">var</span> domObject1 <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment">//   2.2 jQuery对象.get(索引值)</span><span class="token keyword">var</span> domObject2 <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：实际开发比较常用的是把DOM对象转换为jQuery对象，这样能够调用功能更加强大的jQuery中的方法。</p><h2 id="jQuery-选择器">jQuery 选择器</h2><p>​原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。</p><h3 id="基础选择器">基础选择器</h3><p>$(“选择器”)   //  里面选择器直接写 CSS 选择器即可，但是要加引号</p><p>​<img src="https://s2.loli.net/2022/01/25/1Ezq2nr5pQxdTgP.png" alt="基础选择器"></p><h3 id="层级选择器">层级选择器</h3><p>​层级选择器最常用的两个分别为：后代选择器和子代选择器。</p><p>​<img src="https://s2.loli.net/2022/01/25/U1Ynbtu6CA5mapW.png" alt="层级选择器"></p><p><strong>基础选择器和层级选择器案例代码</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>我是div<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是nav div<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>我是p<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>我是ul 的<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>我是ul 的<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>我是ul 的<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".nav"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"ul li"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="筛选选择器">筛选选择器</h3><p>​筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。常见如下 :</p><p><img src="https://s2.loli.net/2022/01/25/ULN5emaTc4MXFlk.png" alt="筛选选择器"></p><p><strong>案例代码</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>多个里面筛选几个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>多个里面筛选几个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>多个里面筛选几个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>多个里面筛选几个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>多个里面筛选几个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>多个里面筛选几个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>多个里面筛选几个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>多个里面筛选几个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>多个里面筛选几个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>多个里面筛选几个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>多个里面筛选几个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>多个里面筛选几个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"ul li:first"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">"color"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"ul li:eq(2)"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">"color"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"ol li:odd"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">"color"</span><span class="token punctuation">,</span> <span class="token string">"skyblue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"ol li:even"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">"color"</span><span class="token punctuation">,</span> <span class="token string">"pink"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另:  jQuery中还有一些筛选方法，类似DOM中的通过一个节点找另外一个节点，父、子、兄以外有所加强。</p><p><img src="https://s2.loli.net/2022/01/25/KBPNucQbqfgCMUY.png" alt="筛选方法"></p><p>偏重于记忆，演示代码略。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JavaScript&quot;&gt;JavaScript&lt;/h2&gt;
&lt;h4 id=&quot;JavaScript-是什么&quot;&gt;JavaScript 是什么&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script </summary>
      
    
    
    
    <category term="JavaScript" scheme="https://www.alexation.cn/categories/JavaScript/"/>
    
    
    <category term="Javascript" scheme="https://www.alexation.cn/tags/Javascript/"/>
    
    <category term="jQuery" scheme="https://www.alexation.cn/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>Lemon - 米津玄師 (よねづ けんし)</title>
    <link href="https://www.alexation.cn/japanese-learning/Lemon/"/>
    <id>https://www.alexation.cn/japanese-learning/Lemon/</id>
    <published>2022-01-10T00:33:46.000Z</published>
    <updated>2022-01-25T04:09:58.415Z</updated>
    
    <content type="html"><![CDATA[<h3 style="text-align:center;font-weight:700;color:#B399FF">Lemon - 米津玄師 (よねづ けんし)</h3><div style="position: relative; width: 100%; height:0; padding-bottom: 10%;"><iframe src="//music.163.com/outchain/player?type=2&id=536622304&auto=1&height=66" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><br><div id="read-article-holder" class="normal-article-holder read-article-holder"></figure><p><strong><span class="color-pink-03">yu me na ra ba do re ho do yo ka tta de sho u</span></strong></p><p>梦（ゆめ）ならば&nbsp; &nbsp; &nbsp;どれほど&nbsp; よかったでしょう</p><p>如果这一切都是梦境该有多好</p><p>&nbsp;</p><p><strong><span class="color-pink-03">&nbsp;i ma da ni a na ta no ko to wo yu me ni mi ru</span></strong></p><p>未（いま）だ&nbsp; &nbsp; &nbsp;にあなた&nbsp; &nbsp; のことを&nbsp; &nbsp; &nbsp;梦（ゆめ）にみる</p><p>至今仍能与你在梦中相遇</p><p><br></p><p><span class="color-pink-03"><strong>wa su re ta mo no wo to ri ni ka e ru yo u ni</strong></span></p><p>忘（わす）れた物（もの）を取（と）りに&nbsp; &nbsp;帰（かえ）る&nbsp; ように</p><p>如同取回遗忘之物一般</p><p><br></p><p><span class="color-pink-03"><strong>fu ru bi ta o mo i de no ho ko ri wo ha ra u</strong></span></p><p>古（ふる）びた思（おも）い出（で）の埃（ほこり）&nbsp; を払（はら）う</p><p>细细拂去将回忆覆盖的尘埃</p><p><br></p><p><span class="color-pink-03"><strong>mo do ra na i shi a wa se ga a ru ko to wo</strong></span></p><p>戻（もど）らない&nbsp; &nbsp; &nbsp;幸（しあわ）せ&nbsp; &nbsp; があることを</p><p>这世间亦有无法挽回的幸福</p><p><br></p><p><span class="color-pink-03"><strong>sa i go ni a na ta ga o shi e te ku re ta</strong></span></p><p>最後（さいご）&nbsp; &nbsp;にあなた&nbsp; &nbsp; が教（おし）え&nbsp; &nbsp; てくれた</p><p>最终是你让我懂得这一点</p><p><br></p><p><span class="color-pink-03"><strong>i e zu ni ka ku shi te ta ku ra i ka ko mo</strong></span></p><p>言（い）えずに隠（かく）してた&nbsp; &nbsp; &nbsp;昏（くら）い過去（かこ）も</p><p>那些未对他人提及过的黑暗往事</p><p><br></p><p><span class="color-pink-03"><strong>a na ta ga i na kya e i e n ni ku ra i ma ma&nbsp;</strong></span></p><p>あなた&nbsp; &nbsp;がいなきゃ 永远（えいえん）に&nbsp; &nbsp; &nbsp; 昏（くら）いまま</p><p>如果不曾有你的话 它们将永远沉睡在黑暗中</p><p><br></p><p><span class="color-pink-03"><strong>ki tto mo u ko re i jo u ki zu tsu ku ko to na do</strong></span></p><p>きっともうこれ以上（いじょう）&nbsp; &nbsp; &nbsp;傷（きず）つくことなど</p><p>比这更令人难过的事情</p><p><br></p><p><span class="color-pink-03"><strong>a ri wa shi na i to wa ka tte i ru</strong></span></p><p>ありはしないとわかっている</p><p>我知道不可能存在</p><p><br></p><p><span class="color-pink-03"><strong>a no hi no ka na shi mi sa e</strong></span></p><p>あの日（ひ）の悲（かな）しみさえ</p><p>那日的悲伤</p><p><br></p><p><span class="color-pink-03"><strong>a no hi no ku ru shi mi sa e</strong></span></p><p>あの日（ひ）の苦（くる）しみさえ</p><p>与那日的痛苦</p><p><br></p><p><span class="color-pink-03"><strong>so no su be te wo a i shi te ta a na ta to to mo ni</strong></span></p><p>そのすべてを&nbsp; &nbsp;爱（あい）してたあなたとともに</p><p>连同深爱着这一切的你</p><p><br></p><p><span class="color-pink-03"><strong>mu ne ni no ko ri ha na re na i</strong></span></p><p>胸（むね）に残（のこ）り離（はな）れない</p><p>化作了深深烙印在我心中的</p><p><br></p><p><span class="color-pink-03"><strong>&nbsp;ni ga i re mo n no ni o i</strong></span></p><p>苦（にが）いレモン&nbsp; &nbsp;の匂（にお）い</p><p>苦涩柠檬的香气</p><p><br></p><p><span class="color-pink-03"><strong>a me ga fu ri ya mu ma de wa ka e re na i</strong></span></p><p>雨（あめ）が降（ふ）り止（や）むまでは&nbsp; &nbsp; &nbsp; 帰（かえ）れない</p><p>在雨过天晴前都无法归去</p><p><br></p><p><br></p><p><span class="color-pink-03"><strong>&nbsp;i ma de mo a na ta wa wa ta shi no hi ka ri</strong></span></p><p>今（いま）でもあなたはわたしの光（ひかり）</p><p>时至今日 你仍是我的光芒</p><p><br></p><p><span class="color-pink-03"><strong>ku ra ya mi de a na ta no se wo na zo tta</strong></span></p><p>暗闇（くらやみ）で&nbsp; &nbsp;あなたの背（せ）をなぞった</p><p>在黑暗中追寻着你的身影</p><p><br></p><p><span class="color-pink-03"><strong>so no ri n ka ku wo se n me i ni o bo e te i ru</strong></span></p><p>その輪郭（りんかく）を鮮明（せんめい）に　覚（おぼ）えている</p><p>那轮廓至今仍鲜明地刻印于心</p><p><br></p><p><span class="color-pink-03"><strong>u ke to me ki re na i mo no to de a u ta bi</strong></span></p><p>受（う）け止（と）めきれないもの　　と出会（であ）うたび</p><p>每当遇到无法承受的苦痛时</p><p><br></p><p><span class="color-pink-03"><strong>a fu re te ya ma na i no wa na mi da da ke</strong></span></p><p>溢（あふ）れてやまないのは　　涙（なみだ）だけ</p><p>总不禁泪如泉涌</p><p><br></p><p><span class="color-pink-03"><strong>na ni wo shi te i ta no</strong></span></p><p>何（なに）をしていたの</p><p>你都经历过什么</p><p><br></p><p><span class="color-pink-03"><strong>na ni wo mi te i ta no</strong></span></p><p>何（なに）を見（み）ていたの</p><p>又目睹过什么呢</p><p><br></p><p><span class="color-pink-03"><strong>wa ta shi no shi ra na i yo ko ga o de</strong></span></p><p>わたしの知（し）らない横顔（よこがお）で</p><p>脸上浮现着我不曾见过的神情</p><p><br></p><p><span class="color-pink-03"><strong>do ko ka de a na ta ga i ma</strong></span></p><p>どこかであなたが今（いま）</p><p>如果你正在什么地方</p><p><br></p><p><span class="color-pink-03"><strong>wa ta shi to o na ji yo u na</strong></span></p><p>わたしと同（おな）じ様（よう）な</p><p>与我一样</p><p><br></p><p><span class="color-pink-03"><strong>na mi da ni ku re sa bi shi sa no na ka ni i ru na ra</strong></span></p><p>涙（なみだ）にくれ&nbsp; &nbsp;淋（さび）しさの&nbsp; &nbsp;中（なか）にいるなら</p><p>终日过着以泪洗面的寂寞生活的话</p><p><br></p><p><span class="color-pink-03"><strong>wa ta shi no ko to na do do u ka wa su re te ku da sa i</strong></span></p><p>わたしのことなどどう　か 　忘（わす）れてください</p><p>就请你将我的一切全部遗忘吧</p><p><br></p><p><span class="color-pink-03"><strong>so n na ko to wo ko ko ro ka ra ne ga u ho do ni</strong></span></p><p>そんなことを心（こころ）から　　願（ねが）うほどに</p><p>这是我发自内深处唯一的祈愿</p><p><br></p><p><br></p><p><span class="color-pink-03"><strong>&nbsp;i ma de mo a na ta wa wa ta shi no hi ka ri</strong></span></p><p>今（いま）でもあなたはわたしの光（ひかり）</p><p>时至今日 你仍是我的光芒</p><p><br></p><p><span class="color-pink-03"><strong>ji bu n ga o mo u yo ri</strong></span></p><p>自分（じぶん）が思（おも）うより</p><p>超出了我自己的想象</p><p><br></p><p><span class="color-pink-03"><strong>ko i wo shi te i ta a na ta ni</strong></span></p><p>恋（こい）をしていたあなたに</p><p>我深深地恋慕着你</p><p><br></p><p><span class="color-pink-03"><strong>a re ka ra o mo u yo u ni i ki ga de ki na i</strong></span></p><p>あれから思（おも）うように&nbsp; &nbsp; &nbsp; &nbsp;息（いき）ができない</p><p>自此每当想起你 都如同窒息般痛苦</p><p><br></p><p><span class="color-pink-03"><strong>a n na ni so ba ni i ta no ni ma ru de u so mi ta i</strong></span></p><p>あんなに　侧（そば）にいたのに&nbsp; &nbsp; まるで嘘（うそ）みたい</p><p>你曾亲密伴我身旁 如今却如烟云般消散</p><p><br></p><p><span class="color-pink-03"><strong>to te mo wa su re ra re na i</strong></span></p><p>とても忘（わす）れられない</p><p>我永远都不会将你遗忘</p><p><br></p><p><span class="color-pink-03"><strong>so re da ke ga ta shi ka</strong></span></p><p>それだけが確（たし）か</p><p>这是唯一能确定的</p><p><br></p><p><span class="color-pink-03"><strong>a no hi no ka na shi mi sa e</strong></span></p><p>あの日（ひ）の悲（かな）しみさえ</p><p>那日的悲伤</p><p><br></p><p><span class="color-pink-03"><strong>a no hi no ku ru shi mi sa e</strong></span></p><p>あの日（ひ）の苦（くる）しみさえ</p><p>与那日的痛苦</p><p><br></p><p><span class="color-pink-03"><strong>so no su be te wo a i shi te ta a na ta to to mo ni</strong></span></p><p>そのすべてを&nbsp; &nbsp;爱（あい）してたあなたとともに</p><p>连同深爱着这一切的你</p><p><br></p><p><span class="color-pink-03"><strong>mu ne ni no ko ri ha na re na i</strong></span></p><p>胸（むね）に残（のこ）り離（はな）れない</p><p>化作了深深烙印在我心中的</p><p><br></p><p><span class="color-pink-03"><strong>&nbsp;ni ga i re mo n no ni o i</strong></span></p><p>苦（にが）いレモン&nbsp; &nbsp;の匂（にお）い</p><p>苦涩柠檬的香气</p><p><br></p><p><span class="color-pink-03"><strong>a me ga fu ri ya mu ma de wa ka e re na i</strong></span></p><p>雨（あめ）が降（ふ）り止（や）むまでは&nbsp; &nbsp; &nbsp; 帰（かえ）れない</p><p>在雨过天晴前都无法归去</p><p><br></p><p><span class="color-pink-03"><strong>ki ri wa ke ta ka ji tsu no ka ta ho u no yo u ni</strong></span></p><p>切（き）り分（わ）けた果実（かじつ）の片方（かたほう）</p><p>の様（よう）に</p><p>如同被切开的半个柠檬一般</p><p><br></p><p><span class="color-pink-03"><strong>&nbsp;i ma de mo a na ta wa wa ta shi no hi ka ri</strong></span></p><p>今（いま）でもあなたはわたしの光（ひかり）</p><p>时至今日 你仍是我的光芒</p><p><br></p></div><p>转自：<a href="https://www.bilibili.com/read/cv9139786">《Lemon》罗马音+假名+中文歌词 - 哔哩哔哩 (bilibili.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 style=&quot;text-align:center;font-weight:700;color:#B399FF&quot;&gt;Lemon - 米津玄師 (よねづ けんし)&lt;/h3&gt;
&lt;div style=&quot;position: relative; width: 100%; height:</summary>
      
    
    
    
    <category term="日语！" scheme="https://www.alexation.cn/categories/%E6%97%A5%E8%AF%AD%EF%BC%81/"/>
    
    
    <category term="日语" scheme="https://www.alexation.cn/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
</feed>
